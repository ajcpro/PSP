<!doctype html>

<html lang=es>
	<head>
		<title>Programación concurrente</title>
		<meta charset=utf-8>
		<meta name=author content="Antonio Cepero">
		<meta name=created content="2021-08-12">
		<meta name=modified content="2021-09-18">
		<link rel=stylesheet href="estilo.css">
	</head>
	<body>
		<article>
			<header>
				<h1>Programación concurrente</h1>
			</header>
			<nav class=toc>
				<ol>
					<li><a href=#hilos>Hilos</a></li>
					<li><a href=#threadpool><em>Thread Pool</em></a></li>
					<li><a href=#futuros>Futuros</a></li>
					<li><a href=#barreras>Barreras</a></li>
				</ol> 
			</nav>
			<section id=Hilos>
				<header>
					<h1 id=hilos>Hilos</h1>
				</header>
<p>Hemos visto dos maneras de trabajar con aplicaciones concurrentes sin
necesidad de tener que gestionar nosotros el mantenimiento de los hilos: el
<b><em>Framework Fork-Join</em></b> y los <b><em>Stream</em></b>. Vamos a ver
ahora, no obstante, cómo podemos trabajar con los <b>hilos de ejecución</b> o
<b><i>threads</i></b>.
<p>Java implementa una clase
<a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html>Thread</a>, que representa un hilo de ejecución, de forma análoga a
como <span class=clase>Process</span> representaba un proceso. Cuando se
ejecuta un programa en Java comienza la ejecución de un hilo. Este hilo se
denomina <b><i>main</i></b> (principal), porque es el que se ejecuta cuando
comienza el programa. Es importante por dos razones:
<ol>
	<li>Es el hilo desde el que se crearán otros hilos
	<li>Es el último hilo que terminará su ejecución ya que realizará
		varias tareas de finalización.
</ol>
<p>Aunque el hilo principal se crea de forma automática, podemos acceder al
mismo a través del método estático <span class=metodo>currentThread</span>(),
que devuelve una referencia al hilo desde el que es invocado.
<pre class=code>
public static void main(String[] args) {
	Thread t = <b>Thread.currentThread</b>();
	System.out.println("Hilo principal: " + t);

	t.<b>setName</b>("Mi Hilo");
	System.out.println("Nuevo nombre: " + t);

	try {
		for ( int i = 3; i > 0; i-- ) {
			System.out.print(i + " ");
			t.<b>sleep</b>(500);
		}
	} catch ( InterruptedException e ) {
		System.out.println(e);
	}
	System.out.println("Fin");
}
</pre>
<p>En el extracto de programa anterior, podemos ver cómo utilizamos este
método: obtenemos, en primer lugar, una referencia al hilo actual, que es el
hilo principal. La siguiente sentencia imprime los datos del hilo: mirando la
especificación del método
<a class=metodo target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html#toString()>toString</a>(), podemos ver que imprime el nombre del hilo,
su prioridad y el grupo al que pertenece. Después, vemos que podemos cambiar
su identificador, si así lo deseamos, con el método
<span class=metodo>setName</span>(). Dar nombres a los hilos no tiene
importancia alguna pero puede ser interesante cuando tenemos varios de ellos
que quieren escribir en la salida estándar, lo que nos permitirá
identificarlos. Podemos obtener su identificador con
<span class=metodo>getName</span>(), que no aparece en el código; o podríamos
usar <span class=metodo>getId</span>(), que nos proporciona su <em>id</em>, un
número entero. Hemos de tener en cuenta, sin embargo, que ese <em>id</em> es
asignado cuando comienza la ejecución del hilo y puede ser reutilizado para la
ejecución de un hilo diferente.
<p>Otro método a destacar es <span class=metodo>sleep</span>(). Podemos
invocarlo, como <span class=metodo>currentThread()</span>, de forma estática,
aunque en este caso se hace asociado a la referencia al hilo actual. Lo que
hace es suspender la ejecución del hilo durante el tiempo especificado como
parámetro, en milisegundos. Hay que tener en cuenta que puede lanzar una
excepción <span class=clase>InterruptedException</span>, por lo que va en el
bloque <i>try-catch</i>. Puede ser provocado con el método
<span class=metodo>interrupt</span>().

<h2>Creación de hilos</h2>
<p>Existen dos formas de crear un nuevo hilo:
<ul>
	<li>Implementar el interfaz
<a class=clase target=_blank
   href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Runnable.html>Runnable</a>
	<li>Extender la clase Thread
</ul>
<p>El método preferido es el de implementar <span class=clase>Runnable</span>,
interfaz que debe ser usado por cualquier clase cuyas instancias se vayan a
ejecutar en un hilo. <b>¿Y por qué es el método preferido? Porque las clases
solo deben extenderse si se va a añadir funcionalidad</b>. Las clases que lo
implementan tienen que crear un método
<span class=metodo>run</span>(), que no recibe parámetros ni devuelve
resultado alguno, que se ejecutará como punto de entrada cuando el hilo
inicie su ejecución y hará que el hilo finalice cuando el método retorne.
Viendo la documentación, vemos que la clase <span class=clase>Thread</span>
implementa el interfaz <span class=clase>Runnable</span>.
<p>La forma de iniciar un hilo es invocando al método
<span class=metodo>start</span>(). Un error muy común es el de invocar al
método <span class=metodo>run</span>() en su lugar. Al principio, no se
aprecia diferencia porque el algoritmo se ejecuta como se esperaba. Sin
embargo, éste no se está ejecutando en un nuevo hilo: lo hace en el mismo
hilo que lo invoca.
<p>De este modo, tendríamos cinco formas diferentes de crear hilos:
<ol>
	<li>Subclase de Thread
	<li>Subclase anónima de Thread
	<li>Implementar Runnable
	<li>Implementación anónima de Runnable
	<li>Lambda de Runnable
</ol>

<h3>Subclase de Thread</h3>
<pre class=code>
class MiHilo extends Thread {
  ...
  public void run() {
    // Cuerpo del hilo
  }
}
</pre>
<p>El primer método consiste en crear una subclase de la clase
<span class=clase>Thread</span>, sobreescribiendo el método
<span class=metodo>run</span>(); éste método es el que será ejecutado
cuando se invoque <span class=metodo>start</span>() para algún objeto de la
clase.
<pre class=code>
Mihilo mh = new MiHilo();
mh.start();
</pre>
<p>Hay que tener en cuenta que <span class=metodo>start</span>() vuelve
tan pronto como se inicia el hilo, sin esperar a que se ejecute
<span class=metodo>run</span>(); el método se ejecutará en una instancia de
ejecución diferente.
<pre class=code>
Thread t = new Thread ( ) {
  public void run ( ) {
    // Cuerpo del hilo
  }
};
t.start();
</pre>
<p>Este segundo ejemplo muestra cómo crear un objeto de una subclase anónima
de Thread. En realidad, ni siquiera sería necesario crear el objeto, si solo
deseamos que se ejecute.
Si deseamos asignar un nombre al hilo al inicio de su ejecución, en lugar de
utilizar <span class=metodo>setName</span>(), podemos hacerlo pasándolo como
parámetro del constructor.
<p>Por último, recordar que <b>el modelo preferido para crear hilos no es
éste</b>: es el siguiente.

<h3>Implementando Runnable</h3>
<pre class=code>
class MiHilo implements Runnable {
  public void run() {
    // Cuerpo del hilo
  }
...
Runnable r = new MiHilo();
new Thread(r).start();
</pre>
<p>La primera manera de utilizar el interfaz Runnable es el de crear una
clase propia que lo implemente. Para crear el hilo e iniciarlo, crearemos
una instáncia de la clase <span class=clase>Thread</span>, a cuyo constructor
pasaremos una instancia de la clase que implementa
<span class=clase>Runnable</span>, y para la que invocaremos el
<span class=metodo>start</span>().
<pre class=code>
Runnable r = new Runnable ( ) {
  public void run ( ) {
    // Cuerpo del hilo
  }
};
</pre>
<p>También se puede crear un objeto de una clase anónima, cuyo ejemplo
podemos ver que es muy similar al que usábamos con Thread.
<pre class=code>
Runnable r = () -> { Cuerpo del hilo };
</pre>
<p>Una tercera forma de hacerlo es con la utilización de una función Lambda.
Esto es así porque el interfaz solo tiene un método abstracto, lo que lo
convierte en un interfaz funcional.
<p>Finalmente, para ejecutarlo, pasamos el objeto de la clase que implementa
Runnable (o la función lambda) al constructor del hilo, el método constructor
de la clase Thread, e invocamos el método <span class=metodo>start</span>().
<p>Podemos también asignar un nombre al hilo, en el constructor, pasándolo
como segundo parámetro del mismo; hay que tener en cuenta que el nombre es
del <span class=clase>Thread</span>, no del <span class=clase>Runnable</span>.
Un error común es confundir el <em>thread</em> con el <em>runnable</em> y
viceversa.
<p>Es importante hacer notar que los hilos se crean cuando invocamos el
método <span class=metodo>start</span>(), ejecutan las instrucciones que
contiene el método <span class=metodo>run</span>() y finalizan cuando el
método <span class=metodo>run</span>() termina su ejecución. Es decir,
que cuando <span class=metodo>run</span>() termina su ejecución, finaliza el
hilo. Esto significa que solo podemos invocar
<span class=metodo>start</span>() una vez, para un objeto de la clase Thread
o de una subclase suya. El objeto, como cualquier otro, seguirá existiendo
mientras haya una referencia al mismo pero el hilo en que se ejecuta no.
<h2>Estados</h2>
<p>Como sucedía con los <a href=01_intro.html#estados>procesos</a>, también
los hilos pueden encontrarse en diferentes
<a target=_blank class=clase 
	href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.State.html>estados de ejecución</a>.
Los estados de los hilos en Java son independientes de cuál sea su estado en el
S.O. y solo pueden encontrarse en uno de ellos en un momento dado.
<div class=image id=img_05_01 style="width:80%;margin-left:10%">
	<img src=imagenes/05_01_estados.png
	     alt="Estados de ejecución de un hilo en Java">
	<p class=caption>Diagrama de estados de ejecución de un hilo en Java<br>
	Imagen tomada de la página de
	<a target=_blank href=https://www.codejava.net/java-core/concurrency/understanding-thread-states-thread-life-cycle-in-java>Nam Ha Minh</a>
</div>
<dl>
	<dt class=palabra>NEW<dt>
	<dd>Significa que el hilo ha sido creado pero no ha comenzado su
	ejecución, es decir, que <span class=metodo>start</span>() no ha sido
	invocado.</dd>
	<dt class=palabra>RUNNABLE<dt>
	<dd>El método <span class=metodo>start</span>() ya ha sido invocado y
	se está ejecutando en el método <span class=metodo>run</span>(); el
	hilo puede pasar a otros estados y volver a éste pero no es elegido
	por el planificador para ejecutarse de forma inmediata: por eso el
	estado es <b><i>runnable</i></b> y no <b><i>running</i></b>.</dd>
	<dt class=palabra>BLOCKED</dt>
	<dd>El hilo ha intentado adquirir un cerrojo intrínseco -se verá más
	adelante qué es- que ya está tomado por otro hilo; permanece esperando
	la liberación del cerrojo por otros hilos y que el planificador le
	permita tomarlo.</dd>
	<dt class=palabra>WAITING</dt>
	<dd>El hilo permanece a la espera de ser notificado por otro hilo
	porque ha invocado <span class=metodo>wait</span>() o
	<span class=metodo>join</span>(); también puede hacerlo si invoca un
	cerrojo del paquete de concurrencia -que veremos más adelante-.</dd>
	<dt class=palabra>TIMED_WAITING</dt>
	<dd>Permanece a la espera pero puede salir de la misma por
	notificación o por expiración de un temporizador.</dd>
	<dt class=palabra>TERMINATED</dt>
	<dd>El método <span class=metodo>run</span>() ha finalizado su
	ejecución (sea normalmente o por una excepción).</dd>
</dl>

<h3>Ejemplo</h3>
<p>Veamos, en un ejemplo, cómo creamos un nuevo hilo:
<pre class=code>
    Thread t = new Thread(new Runnable() {
        public void run() {
            Thread self = Thread.currentThread();
            System.out.println(self.getName() + " es "
                             + self.getState());
            }
        });
</pre>
<p>Lo hacemos con un objeto anónimo que instanciamos en el constructor del hilo.
Su método <span class=metodo>run</span>() es muy sencillo: obtiene una
referencia al objeto <span class=clase>Thread</span> e imprime su nombre y
estado. La creación no significa que empiece a ejecutarse por lo que, si
hacemos una primera llamada a <span class=metodo>getState</span>() devolverá
el valor <span class=palabra>NEW</span>:
<pre class=code>
    System.out.println(t.getName() + " es " + t.getState());
</pre>
<p>Tras la invocación de start() se ejecutará el hilo invocando al método run().
<pre class=code>
    t.start();
</pre>
<p>Esto hará que <span class=metodo>getState</span>() se ejecute por segunda vez
pero, ahora, lo hará dento del método <span class=metodo>run</span>(), en el
nuevo hilo, por lo que la salida será: <span class=palabra>RUNNABLE</span>.
<pre class=code>
    t.join(); // Espera a la finalización del hilo
</pre>
<p>Hemos añadido un método nuevo, que no habíamos comentado hasta ahora:
<span class=metodo>join</span>(). Como sabemos, <em>join</em> es la función
que, tradicionalmente, se utiliza para esperar la finalización de la
ejecución de otro proceso o tarea -y así lo utilizamos en el <i>fork-join
framework</i>-. En este caso, hará que el hilo principal espere a la
finalización del otro hilo, antes de continuar con su ejecución.
Tras ello, finalizará la ejecución del hilo y continuará la del hilo principal.
<pre class=code>
    if ( t.getState() == Thread.State.TERMINATED ) {
        System.out.println(t.getName() + " ha finalizado.");
    }
</pre>
<p>Por último, comprobamos que el hilo ha finalizado examinando su estado.
Podemos también aquí apreciar la diferencia entre el <em>hilo de ejecución</em>
y el objeto de la clase <span class=clase>Thread</span>: podemos seguir
utilizando la referencia a <em>t</em> aunque el hilo ya ha finalizado su
ejecución. Además, como ya se ha indicado, no es posible volver a invocar el
método <span class=metodo>start</span>().
<p>A continuación, el código completo dentro de un programa:
<pre class=code>
public static void main ( String[] args ) throws InterruptedException {
    Thread t = new Thread(new Runnable() {
        public void run() {
            Thread self = Thread.currentThread();
            System.out.println(self.getName() + " es "
                             + self.getState());
            }
        });

    System.out.println(t.getName() + " es " + t.getState());

    t.start();

    t.join(); // Espera a la finalización del hilo

    if ( t.getState() == Thread.State.TERMINATED ) {
        System.out.println(t.getName() + " ha finalizado.");
    }
}
</pre>
<p>El método <span class=metodo>main</span>() lanza la excepción
<span class=clase>InterruptedException</span>. Ésta es lanzada por el método
<span class=metodo>join</span>() cuando otro hilo ha interrumpido a éste.
Dado que este programa no define otro hilo que pueda causar la interrupción,
resulta innecesario capturarla.

<h2>Prioridad</h2>
<p>¿Cuál es el hilo preferido para la ejecución, en caso de existir muchos
hilos? ¿Cómo decide el planificador cuál se ejecuta de aquellos en estado
<span class=palabra>RUNNABLE</span>?
<p>Cada hilo tiene un valor de prioridad; esta prioridad es un valor numérico
entre <span class=palabra>MIN_PRIORITY</span>, que vale 1, y
<span class=palabra>MAX_PRIORITY</span>, que vale 10; se define también el
valor <span class=palabra>NORM_PRIORITY</span>, que es 5, valor asignado al
hilo si no se ha definido otra cosa. Por defecto, cuando un hilo se crea,
hereda la prioridad del hilo desde el que es creado.
<p>En líneas generales, Java utiliza un planificador apropiativo pero, a la
hora de elegir qué hilo se ejecutará, lo selecciona de entre aquellos que
tienen mayor prioridad. No obstante, el método
<a target=_blank class=metodo
   href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Thread.html#yield()>yield</a>() indica al planificador que está dispuesto a
detenerse, aunque el planificador puede ignorar este hecho: comprobará si
existe algún otro hilo con igual o mayor prioridad y, en caso de que no,
continuará la ejecución de este hilo. Según la documentación, no suele ser
apropiado utilizar este método.

<h2>Agrupaciones de hilos</h2>
<p>Un grupo de hilos es una clase, <a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/ThreadGroup.html>ThreadGroup</a>,
que permite asociar hilos relacionados entre
sí como una unidad, permitiendo llevar a cabo acciones sobre el grupo como un
todo, en lugar de sobre cada hilo por separado. Esto es útil en situaciones en
las que deseas detener, volver a poner en ejecución o finalizar unos
determinados hilos o que están relacionados. Por ejemplo, imaginemos un
programa en que un grupo de hilos recibe datos, otro grupo los procesa, un
tercero los muestra y otro los imprime; si se cancela la impresión, los grupos
de hilos permiten detener simultáneamente todos los hilos dedicados a dicha
tarea.
<p>Existen dos constructores en los que, para ambos, una cadena especifica el
nombre del grupo. Si solo se especifica éste, se crea un grupo cuyo padre es
el hilo actual. Si se utilizan dos parámetros, el primero indicará qué grupo
es el grupo padre del que se está creando. Como indica la especificación de la
clase: <span class=cita>"los grupos de hilos forman un árbol en el que cada
grupo tiene un padre a excepción del grupo de hilos inicial"</span>.
<pre class=code>
public static void main(String[] args) {
    ThreadGroup miGrupo = new ThreadGroup("Mi Grupo");

    class MiHilo implements Runnable {
        public void run() {
            for ( ; ; ) {
                try {
                    System.out.println("Estoy vivo: "
                             + Thread.currentThread().getName());
                    Thread.sleep(1000);
                } catch (InterruptedException ex) {
                    System.out.println("Me han cancelado: "
                             + Thread.currentThread().getName());
                    return;
                }
            }
        }
    }

    for ( int i = 0; i < 4; i++ )
        new Thread(miGrupo, new MiHilo(), "Hilo " + i).start();

    try {
        Thread.sleep(4000);
    } catch ( InterruptedException e ) {
        System.out.println(e);
    }

    miGrupo.interrupt();
}
</pre>
<p>En este sencillo ejemplo, creamos un grupo denominado <em>miGrupo</em>.
Tenemos también una clase que implementa el método funcional
<span class=clase>Runnable</em> de manera que se ejecuta indefinidamente; lo
que hace es imprimir un mensaje con el nombre del hilo en que se ejecuta cada
segundo, hasta que es interrumpido (por otro hilo). A continuación, crea
cuatro hilos, que podrían ser el número que quisiéramos, cuyos ejecutables son
objetos de la clase que hemos definido antes, y esperamos durante cuatro
segundos. Tras ello, interrumpe a todo el grupo.
<p>Este programa imprimirá dieciséis (16) mensajes del tipo <em>Estoy vivo:
Hilo X</em>, correspondientes a la ejecución de los cuatro hilos, siendo
<em>X</em> un valor que variará de cero (0) a (3), cada cuatro (4) ocasiones.
Finalmente, se imprimirá cuatro veces el mensaje <em>Me han cancelado: Hilo
X</em> y terminará el programa. Esto es así porque, intencionadamente, hemos
capturado la interrupción y terminado la ejecución con <em>return</em>. De no
haberlo hecho así, los cuatro hilos seguirían ejecutándose indefinidamente y
el programa no finalizaría.
<p>Podéis ampliar este programa para ver el grupo al que pertenece el hilo
principal, cuántos hilos contiene, los que contiene <em>miGrupo</em>...


			<section id=ThreadPool>
                                <header>
                                        <h1 id=threadpool><em>Thread Pool</em></h1>
                                </header>


<p>En general, la tarea de crear hilos requiere que el SO dedique una serie de
recursos que hacen que la operación sea muy costosa, especialmente en
aplicaciones que creen muchos hilos con una vida corta. Por ello, en la
práctica, las aplicaciones que deben ejecutar muchos hilos así, en lugar de
crear un nuevo hilo cada vez que deban ejecutar una tarea, pueden utilizar un
conjunto de hilos asociados de manera que, cuando la tarea deba ser ejecutada,
ésta sea asignada a uno de esos hilos; cuando la tarea finaliza, en lugar de
liberar los recursos del hilo, éste queda ocioso a la espera de que una nueva
tarea deba ser ejecutada. Análogamente, si debe ejecutar más tareas que hilos
tiene asociados (y todos están ocupados), puede utilizar algún tipo de cola o
similar en la que esas tareas esperen hasta la liberación de algún hilo.
<p>Este tipo de estructuras se utiliza ampliamente en servidores multihilo.
Cada vez que se establece una conexión con el servidor a través de la red, la
misma se asocia a una tarea que es añadida al <a target=_blank
href=https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html>Thread Pool</a>
y los hilos del mismo procesarán las conexiones de forma concurrente.
<p>En general, no hace falta implementar un <em>Thread Pool</em> propio ya que
Java proporciona varios en el paquete de concurrencia, como el
<em>Fork Join</em>, con el que ya hemos trabajado.
<p>La manera de utilizar un <i>thread pool</i> es a través de un
<a target=_blank href=https://docs.oracle.com/javase/tutorial/essential/concurrency/exinter.html>ejecutor</a>.
El ejecutor es un interfaz, <a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Executor.html>Executor</a>,
de alto nivel para la gestión de los <i>thread pools</i>; de alguna manera, el
ejecutor es la implementación Java de los <i>thread pools</i>. Básicamente,
contiene un método para ejecutar una tarea, en lugar de tener que iniciar un
hilo. De este modo, si lo que haríamos normalmente es crear un hilo a partir
de un objeto perteneciente a una clase que implementa
<span class=clase>Runnable</span> y ejecutarlo invocando el método
<span class=metodo>start</span>(), con el ejecutor invocaremos el método
<a class=metodo target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Executor.html#execute(java.lang.Runnable)>execute</a>(),
al que pasaremos como parámetro ese objeto de una clase Runnable.
<p>Dicho de otro modo, donde, por ejemplo,  hubiéramos escrito:
<pre class=code>
Thread t = new Thread(new Runnable());
t.start();
</pre>
<p>Ahora pondremos:
<pre class=code>
Executor ejecutor = algunExecutor;
ejecutor.execute(new Runnable());
ejecutor.execute(new Runnable());
</pre>

<h3>Servicio de ejecución</h3>
<p>El interfaz <a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ExecutorService.html>ExecutorService</a>
es un mecanismo de ejecución asíncrona que puede ejecutar tareas en segundo
plano de forma concurrente, proporcionando métodos para gestionar la
terminación o producir futuros.
<p>Para crearlo, podemos utilizar uno de los definidos en la clase
<a class=clase target=blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Executors.html>Executors</a>,
cualquiera de los métodos que comienzan por <em>new</em>, según el tipo de
<i>Thread Pool</i> que mejor se adapte a nuestro problema. Para ejecutar
tareas, como <span class=clase>Executor</span> es un superinterfaz de éste,
podemos seguir utilizando el método <span class=metodo>execute</span>(); pero,
además, proporciona un método <span class=metodo>submit</span>() al que
podemos pasar objetos <span class=clase>Runnable</span>.
Una vez que todas las tareas hayan finalizado debemos
detener el ejecutor de manera ordenada, recurriendo al método
<span class=metodo>shutdown</span>(). De no hacerlo así, los hilos seguirán
<em>vivos</em> y nuestro programa no terminará su ejecución.

<h4>Ejemplos</h4>
<pre class=code>
public static void main(String[] args) {
    final int NUM_HILOS = 8;

    ExecutorService ejecutor =
                    Executors.newFixedThreadPool(NUM_HILOS);

    for ( int i = 0; i &lt; NUM_HILOS * 2; i++ )
        ejecutor.execute(() -&gt; {
            System.out.println("Soy el hilo: "
                        + Thread.currentThread().getName());
            });

        System.out.println("Programa principal esperando");

        ejecutor.shutdown();

        System.out.println("Ejcutor finalizado");
}
</pre>
<p>En el ejemplo anterior podemos ver cómo creamos el <em>Thread Pool</em>:
utilizamos <span class=clase>newFixedThreadPool</span>(), que genera un
conjunto fijo de hilos; en este caso, lo hacemos de 8 hilos. A continuación,
creamos el doble de tareas que hilos tenemos y delegamos su control al
ejecutor. El programa principal imprime un mensaje y queda en suspenso hasta
que el ejecutor finalice su actividad; es decir, hasta que todas las tareas
hayan finalizado y terminen los hilos. Finalmente, imprime el mensaje de
finalización.
<p>El programa generará un mensaje para cada una de las tareas pudiendo
observar como, para más de una, el nombre del hilo en que se ejecuta, debido
a que hemos usado <span class=metodo>getName()</span>, se repite.

                        </section>
                        <section id=Futuros>
                                <header>
                                        <h1 id=futuros>Futuros</h1>
                                </header>

<p>Imaginemos que tenemos un valor <em>A</em> que se obtiene de aplicar una
función <em>F</em> a otro valor <em>B</em>; y dos valores, <em>C</em> y
<em>D</em>, que se obtienen, respectivamente, de aplicar las funciones
<em>G</em> y <em>H</em> a <em></em>A.
<br><span class=code>A = F(B)</span>
<br><span class=code>C = G(A)</span>
<br><span class=code>D = H(A)</span>
<br>Esto es un caso típico de un programa cualquiera, en el que invocamos
distintos métodos (que devuelven un resultado) para asignar valores a las
variables.
<p>Vemos como la invocación a <em>G</em> y <em>H</em> puede ser realizada en
paralelo ya que ambas dependen de <em>A</em>, pero no dependen una de la otra.
La única condición para que puedan ejecutarse reside en que <em>A</em> esté
disponible. Y eso es lo que queremos, que puedan ejecutarse en cualquier
orden: vamos a ver cómo podemos expresar ese paralelismo. Deseamos crear una
tarea asíncrona con el método <em>F</em>, pero vamos a llamarla <b>futuro</b>.
Para lo que sería la variable <em>A</em>, indicamos una <em><b>futuro de
A</b></em>, <em>FA</em>, a la que asignamos el resultado del futuro de
<em>F(B)</em>. Es decir, creamos un <em><b>futuro de la función</b></em> y el
resultado es algo denominado un <b>objeto futuro</b>.
<br><span class=code>FA = FUTURE{F(B)}</span>
<br>A continuación queremos usar el valor de <em>A</em>, por lo que, cuando
invoquemos el futuro de <em>G(A)</em>, lo haremos a través del método
<span class=metodo>get</span> del <em>futuro de A</em>:
<span class=code style="margin-left: 0">FA.get()</span>.
<br><span class=code>FC = FUTURE{G(FA.get())}</span>
<br><span class=code>FD = FUTURE{H(FA.get())}</span>

<p>¿Qué son entonces ese objeto futuro y el método
<span class=metodo>get</span>? El futuro es un manejador para el objeto y, en
el mismo, estará el valor final de <em>A</em>.
Por lo que la diferencia entre <em>A</em> y <em>FA</em>, es que <em>FA</em> es
un <b>envoltorio</b> (<b><i>wrapper</i></b>) para <em>A</em>, y ese valor es el
devuelto. Así que cuando hacemos el <em>futuro de F(A)</em> es equivalente a
que lancemos una tarea asíncrona y el programa continúe con la siguiente
instrucción: no se produce un bloqueo cuando se crea el futuro. Ahora bien,
cuando se necesita el valor de <em>A</em>, cuando hacemos el <em>FA.get()</em>,
es entonces cuando se producirá un bloqueo u operación de espera (<i>wait</i>)
hasta que el valor de <em>A</em> esté disponible.
<div class=image id=img_05_02 style="width:80%;margin-left:10%">
	<img src=imagenes/05_02_futuro.png style="width:15em"
	     alt="Representación de un futuro, que, en este caso, puede ser
		  considerado com un envoltorio o contenedor en el que se
		  depositará el valor esperado">
	<p class=caption>Representación de un futuro<br>
</div>
<p>Eso significa que todas las tareas pueden ejecutarse en paralelo y no se
producirán errores porque <em>G</em> no se ejecutará mientras el valor de
<em>A</em> no esté disponible. Y también el cálculo de <em>D</em> puede
realizarse en paralelo.
<p>Fácilmente podemos deducir que podríamos aplicar este método a
nuestro ejemplo de la suma de elementos de un vector, si utilizamos dos
futuros, uno para el cálculo de la suma de los elementos de la parte
izquierda y otro para la suma de los elementos de la parte derecha; y
aplicamos el método <span class=metodo>get</span> para obtener la suma final.
Como vimos, el <i>Fork-Join framework</i> ya nos proporciona esta posibilidad:
podemos asimilar el <span class=metodo>fork</span> con el futuro de la suma y
el método <span class=metodo>get</span> con <span class=metodo>join</span>.
<p>Y en general, puede ser aplicado a cualquier programa, haciendo que sus
métodos se conviertan en tareas asíncronas asociadas a un futuro.

<h2><i>Callable</i></h2>
<p><a class=clase target=_blank
      href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Callable.html>Callable</a>
es un interfaz que, como <span class=clase>Runnable</span>, representa una
tarea que puede ser ejecutada en un hilo o en un <i>thread</i> pool. Ambos son
interfaces funcionales y la diferencia entre uno y otro reside en que
<span class=clase>Callable</span> define un método
<span class=metodo>call</span>(), en lugar de <span class=metodo>run</span>().
Lo que distingue a call() es que puede devolver un valor y/o lanzar una
excepción, mientras que <span class=metodo>run</span>() no.
<p>La idea reside en que el resultado del método
<span class=metodo>call</span>() lo asignaremos a un objeto que cumpla con el
interfaz <a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Future.html>Future</a>,
permitiendo así la ejecución asíncrona.


<pre class=code>
public static void main(String[] args) {
    ExecutorService ejecutor = Executors.newSingleThreadExecutor();

    ArrayList&lt;Callable&lt;String&gt;&gt; tareas = new ArrayList();
    for ( int i = 0; i &lt; 3; i++ ) {
        final int num = i;
        tareas.add(() -&gt; "Tarea" + num );
    }

    ArrayList&lt;Future&lt;String&gt;&gt; salida =
      (ArrayList&lt;Future&lt;String&gt;&gt;) ejecutor.invokeAll(tareas);

    try {
        for ( Future&lt;String&gt; f: salida )
            System.out.println(f.get());
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }

    ejecutor.shutdown();
}
</pre>
<p>En este ejemplo utilizamos
<span class=clase>newSingleThreadExecutor</span>(), que utiliza un único hilo.
A continuación, creamos una colección de objetos que implementan el interfaz
<span class=clase>Callable</span> y asignamos una tarea cuya única función es
devolver la cadena de texto <em>Tarea</em>, seguida del número de tarea. Para
poder hacer asíncrono el resultado, definimos una nueva colección, esta vez de
<span class=clase>Future</span>, y le asignamos la salida del método
<span class=metodo>invokeAll</span>, que ya conocíamos del
<span class=clase>ForkJoinPool</span>. Se hace el <i>cast</i> porque devuelve
una lista genérica. Hemos creado una constante intermedia <em>num</em> para
utilizarla en la función lambda, en la que no podemos usar <em>i</em>
directamente. Por último, con el método <span class=metodo>get</span>()
esperaremos a que el valor del futuro esté disponible e imprimiremos su
contenido.
<p>Hemos de tener en cuenta que la tarea puede provocar una excepción y que el
futuro no puede determinar si ha finalizado con éxito o no.
<p>En algunas ocasiones nos puede interesar, como ya vimos, el no determinismo
benigno, en el que cualquier solución es buena. Para ellos disponemos del
método <span class=metodo>invokeAny</span>(): en este caso, solo devolverá un
valor, en caso de que una tarea finalice correctamente, cancelando la
ejecución del resto de tareas.

<!-- Hay que añadir FutureTask -->
			</section>

			<section id=Sincro>
				<header>
					<h1 id=sincro>Comunicación entre procesos</h1>
				</header>


			</section>

			<section id=Barreras>
				<header>
					<h1 id=barreras>Barreras</h1>
				</header>

<h3>Barrera</h3>
<p>Supongamos que tenemos un bucle como el siguiente:
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	println("Adios " + i);
}
</pre>
<p>es un forall que se ejecuta <em>n</em> veces y que imprime una sucesión de
<em>hola</em> y <em>adios</em>, seguidos del número de iteración. Si en lugar
de un <em>forall</em> fuera un <em>for</em> siempre veríamos <em>hola</em>
seguido de <em>adios</em>, con números consecutivos del <em>0</em> al
<em>n</em>.
<p>¿Cómo se ejecutarán en paralelo? Como sabemos, es no determinista:
diferentes ejecuciones proporcionarán resultados diferentes, imprimiendo las
cadenas en distintos órdenes. Por ejemplo, podemos tener <em>hola 2</em>
seguido de <em>hola 6</em>, seguido de <em>adios 2</em>, <em>hola 4</em>,
<em>hola 5</em>, <em>adios 6</em>, <em>adios 5</em>, etc. Esto significa que
hay múltiples resultados, en diferentes órdenes, pero con una restricción:
que los <em>hola</em> y <em>adios</em> correspondientes al mismo número
siempre deben ir en ese orden. O lo que es lo mismo, tendremos <em>hola 2</em>
seguido de <em>adios 2</em>, <em>hola 4</em> seguido de <em>adios 4</em>, etc.
Para cualquier otro caso, todas las permutaciones son correctas.
<p>Pero supongamos que queremos añadir una nueva restricción: que todos los
<em>hola</em> sean impresos antes que todos los <em>adios</em>. ¿Cómo
podríamos modificar ese código para conseguir lo que buscamos? Una
posibilidad sería crear un segundo bucle: tenemos un bucle para el
<em>hola</em> y otro para el <em>adios</em>. Supongamos, sin embargo, que no
es imprimir <em>hola</em> degido del número <em>i</em> de la iteración, sino
que queremos realizar alguna operación con ello y es el resultado de dicha
operación con lo que vamos a trabajar en la segunda parte (no imprimir
<em>adios</em>). En ese caso, crear dos bucles no es una buena opción ya que
habrá que hacer algo para comunicar el valor desde el primer bucle al segundo
o realizar el cálculo nuevamente, lo que podría ser muy costoso.
<p>Tenemos una construcción que denominamos <span class=palabra>BARRERA</span>
y lo que hace es asegurarse de que, si tienes un bucle paralelo, todas las
iteraciones alcanzan la <b>barrera</b> y ninguna de ellas continua su avance
hasta que todas han llegado a ese punto. Así, al considerar las impresiones
utilizando la barrera, puedes obtener cualquier permutación de hola pero ni un
solo adios hasta que todos los hola hayan sido impresos. Y a continuación,
cualquier permutación de adios.
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	<span class=palabra>BARRERA</span>
	println("Adios " + i);
}
</pre>
<p>Recibe el nombre de barrera precisamente por eso: es un punto de espera
para todas las tareas, que debe ser alcanzado por todas ellas antes de
continuar con la siguiente <b>etapa</b> o <b>fase</b>. De hecho, nos referimos
a ello como <b>fase 0</b>, <b>fase1</b>, etc. En definitiva, el mecanismo es
un método de sincronización entre tareas (independientemente de que utilicemos
un bucle como ejemplo).
<p>En Java existe una clase denominada <a class=clase target=_blank 
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/CyclicBarrier.html>CyclicBarrier</a>, que implementa una barrera,
utilizando el método <span class=metodo>await</span>() para la sincronización.
En el siguiente ejemplo pasamos a su constructor el número de tareas que van a
alcanzar la barrera; esto es necesario para que la barrera sepa a cuántos
hilos debe esperar.

<pre class=code>
<b>CyclicBarrier barrera = new CyclicBarrier(10)</b>;

for ( int i = 0; i &lt; 10; i++ ) {
	final int num = i;
	new Thread(() -&gt; {
		System.out.println("Hola "  + num);
		try { <b>barrera.await()</b>; } catch (Exception e) {}
		System.out.println("Adios "  + num);
	}).start();
}
</pre>


<h3 class=tooltip>Fáser<span class=tooltiptext>Traducción libre que el autor
ha dado al término <i>phaser</i>, al desconocer otro y no haber encontrado
uno alternativo en la red.</span></h3>

<p>Volvamos a nuestro ejemplo anterior, en que imprimíamos <em>hola</em> y
<em>adios</em>. Colocamos una barrera para que mostrara primero todos los
<em>hola</em> y posteriormente todos los <em>adios</em>. Pero supongamos que
yo quiero hacer algo entre medio, algo que debe ejecutarse después de su
<em>hola</em> correspondiente pero puede realizarse de forma asíncrona con el
resto de <em>hola</em> o, incluso, con los <em>adios</em>. Es decir, los
<em>adios</em> deben ejecutarse siempre después de todos los <em>hola</em>
pero, aunque ya hayan empezado a ejecutarse, todavía puede estar ejecutándose
ese algo intermedio. Por ejemplo, modificamos el código añadiendo un mensaje
de <em>Llegué</em>.
<p>¿qué sucede si la barrera se coloca tras el nuevo mensaje?
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	println("Llegué " + i);
	<span class=modificado>BARRERA</span>
	println("Adios " + i);
}
</pre>
<p>En este caso, como podemos ver, nada cambia: algunos <em>llegué</em> pueden
ir antes que otros <em>hola</em> pero ningún <em>adios</em> se ejecutará antes
que un <em>hola</em>. Y daría igual si lo hubiéramos puesto después de la
barrera:
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	<span class=modificado>BARRERA</span>
	println("Llegué " + i);
	println("Adios " + i);
}
</pre>
<p>se imprimirían todos los <em>hola</em> y, una vez terminados, la secuencia
de <em>llegué</em> y <em>adios</em> sin un orden preestablecido. ¿Realmente
sería igual? Es evidente que este ejemplo parece poco significativo pero, en
un algoritmo real, el coste de ejecución de la barrera y el del cálculo que
deba realizarse en ese punto se sumarían, lo que conlleva una sobrecarga
innecesaria, que podríamos reducir fácilmente si ambos pudieran solaparse:
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	<span class=modificado>BARRERA</span>?
	println("Llegué " + i);
	<span class=modificado>BARRERA</span>?
	println("Adios " + i);
}
</pre>
<p>Y ahí es precisamente donde los <b>fáseres</b> tienen
	su relevancia. Un <b>fáser</b> es un objeto que, como la barrera,
divide un programa en etapas o fases. En este caso, tenemos dos métodos:
<em>llegada</em> y <em>espera y avanza</em>. ¡Y eso es la barrera: llega,
espera y avanza! Pero lo interesante es que la hemos dividido en dos partes:
la parte de <em>llegada</em>, en la que dice que ya ha finalizado la fase que
todos deben finalizar; y la de <em>espera y avance</em>, en la que la tarea
esperará a que todas las demás hayan finalizado antes de proseguir.
<pre class=code>
forall ( i: [0:n] ) {
	println("Hola " + i);
	<span class=palabra>LLEGADA</span>
	println("Llegué " + i);
	<span class=palabra>ESPERAyAVANZA</span>
	println("Adios " + i);
}
</pre>
<p>Entonces, ¿qué nos proporciona a nosotros en nuestro algoritmo? Después del
<em>hola</em>, colocamos la llegada, con lo que estamos informando de que
hemos hecho ya el <em>hola</em>. Tras el mismo no nos detenemos, pudiendo
imprimir el <em>llegué</em> pero, a continuación, esperamos a que todos los
demás <em>hola</em> hayan sido impresos, es decir, que no continuaremos
imprimiendo <em>adios</em> hasta que todos los <em>hola</em> hayan finalizado,
pero lo haremos una vez suceda, aunque otros hilos aún no hayan impreso su
<em>llegué</em>.
<p>Notad que ahora, en un programa que usara esta técnica, el costo del camino
se habría reducido al haber podido ejecutar en paralelo el costo de la barrera
y de la parte de la tarea que se realiza localmente.
<p>Como antes, implementamos nuestro ejemplo en Java.
<pre class=code>
<b>Phaser ph = new Phaser(10)</b>;
for ( int i = 0; i &lt; 10; i++ ) {
	final int num = i;
	new Thread(() -&gt; {
		System.out.println("Hola "  + num);
		int <b>fase = ph.arrive()</b>;
		System.out.println("Llegué "  + num);
		<b>ph.awaitAdvance(fase)</b>;
		System.out.println("Adios "  + num);
    }).start();
}
</pre>
<p>En esta ocasión utilizamos la clase <a class=clase target=_blank
href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/Phaser.html>Phaser</a>
que, entre otros métodos tiene el <span class=metodo>arrive</span>() y el
<span class=metodo>awaitAdvance</span>(); también dispone de un método
<span class=metodo>arriveAndAwaitAdvance</span>(), que puede ser utilizado
como si de una barrera se tratara. Al igual que antes, al crearlo, indicamos
cuántos hilos van a hacer uso del mismo. A diferencia del uso de la barrera,
sin embargo, el método <span class=metodo>arrive()</span> no se bloquea y nos
devuelve un valor de <b>fase</b> o etapa en la llegada. Ese número de fase es
el que deberemos pasar a <span class=metodo>awaitAdvance()</span> para
indicarle cuándo puede proseguir.

<h3>Sincronización punto a punto</h3>
<p>Vamos a ver ahora una aplicación muy interesante de los fáseres: la
sincronización punto a punto.
<p>Imaginemos que tenemos tres tareas, de manera que, en cada una de ellas se
está haciendo algún trabajo. La <em>tarea 0</em> está calculando el valor de
<em>X</em> como una función <em>A</em>, la <em>tarea 1</em> hace lo propio con
<em>Y</em> y la <em>tarea 2</em> calcula <em>Z</em>. Posteriormente, estos
valores van a ser utilizados por las tareas para otro cálculo; por ejemplo, la
<em>tarea 0</em> utiliza <em>X</em> e <em>Y</em>, la <em>tarea 1</em> los tres
valores y la <em>tarea 2</em> usa <em>Y</em> y <em>Z</em>:
<br><span class=code>/* Tarea_0 */ X = A(); D(X, Y)</span>
<br><span class=code>/* Tarea_1 */ Y = B(); E(X, Y, Z);</span>
<br><span class=code>/* Tarea_2 */ Y = C(); F(Y, Z);</span>
<p>Queremos que no existan condiciones de carrera pero, como los valores se
calculan en paralelo y las tareas utilizan valores obtenidos por otras tareas,
sabemos que podrían producirse si no lo evitamos de alguna manera. Aunque
conocemos un método para hacerlo: podemos añadir una barrera.
<div class=image id=img_05_03 style="width:80%;margin-left:10%">
	<img src=imagenes/05_03_ppb.png style="width:95%"
	alt="Representación de la ejecución de las tareas,
	sincronizadas con un barrera, para que ninguna ejecute la segunda
	fase sin que los valores que debe usar estén disponibles.">
	<p span=caption>Representación de la ejecución de las tareas con
	barrera
</div>

<p>Con esta medida, nos hemos asegurado de que todas las tareas completarán
la primera fase, calcular <em>X</em>, <em>Y</em> y <em>Z</em>, de manera
independiente, y solo cuando hayan terminado pasarán a la segunda fase, en la
que utilizarán los valores de <em>X</em>, <em>Y</em> y <em>Z</em>.
<p>Vamos a ver qué sucede con el coste de ejecución. Supongamos que los costes
son: <b>1</b> para el cálculo de <em>X</em>, <b>2</b> para el de <em>Y</em>
y <b>3</b> para el de <em>Z</em>; y al revés, <b>3</b> el de la segunda fase
de la <em>tarea 0</em>, <b>2</b> el de la <em>1</em> y <b>1</b> el de la
<em>3</em>.
<p>Podemos ver que el camino crítico tendrá un coste de <b>6</b> porque el
cálculo de <em>Z</em> cuesta <b>3</b> y el de la segunda fase de la <em>tarea
0</em> es también de <b>3</b>. Así que la pregunta es: ¿podemos hacerlo
mejor? Si nos fijamos bien, el cálculo del método <em>D</em> en la <em>tarea
0</em> no necesita esperar a que la <em>tarea 3</em> haya calculado
<em>Z</em>. En realidad, si nos fijamos en las flechas de la imagen, la
<em>tarea 0</em> utiliza <em>Y</em> desde otra tarea; la <em>tarea 1</em>
necesita <em>X</em> de la <em>tarea 0</em> y <em>Z</em> de la
<em>tarea 2</em>; y la <em>tarea 3</em> necesita <em>Y</em> de la
<em>tarea 1</em>.

<p>Si utilizamos fáseres podemos organizar estas sincronizaciones de manera
más apropiada a la de la barrera. Debemos utilizar un número mayor de
fáseres de manera que, en este caso de ejemplo, podemos tener 3, uno por
resultado. Cada tarea anunciará cuándo tiene calculado su valor con su
llegada pero van a ser algo más quisquillosos con a qué esperan: la
<em>tarea 0</em> esperará al fáser de <em>Y</em> y <b>solo al de
<em>Y</em></b>; la <em>tarea 1</em> deberá esperar a los fáseres de
<em>X</em> y <em>Z</em>; mientras que la <em>tarea 2</em> también esperará
al fáser de <em>Y</em>.
<div class=image id=img_05_04 style="width:80%;margin-left:10%">
	<img src=imagenes/05_04_ppf.png style="width:95%"
	alt='Representación de la ejecución de las tareas,
	sincronizadas con tres fáseres, uno por valor. Tras calcular cada
	uno de ellos realiza un "arrive" y, a continuación, ejecuta
	el "awaitAdvance" para cada valor que debe utilizar.'>
	<p class=caption>Representación de la ejecución de las tareas con
	fáseres. Tened en cuenta que el <b>espera</b> de la imagen es un
	<b>espera y avanza</b>.
</div>


<p>Si analizamos ahora el camino crítico nos encontramos con que éste es 5:
hay dos posibilidades:
<ul>
	<li>las dos unidades de trabajo de la primera fase de la <em>tarea
	1</em> y las tres de la segunda de la <em>tarea 0</em>
	<li>las tres unidades de trabajo de la primera fase de la <em>tarea
	2</em> y las dos de la segunda de la <em>tarea 1</em>
</ul>
<p>Este simple ejemplo demuestra que los fáseres pueden proporcionar mayor
paralelismo que las barreras.

			</section>

			<section id=Cerrojos>
				<header>
					<h1 id=cerrojos>Cerrojos</h1>
				</header>


			</section>

			<section id=Actor>
				<header>
					<h1 id=actor>Modelo de actor</h1>
				</header>


			</section>

			<footer>
<nav class=pie>
        <a class=previo href=04_progpar.html>Programación paralela</a>
        <a class=inicio href=index.html>Índice</a>
        <a class=siguiente></a>
</nav>
		<p>Programación de servicios y procesos</p>
			</footer>
		</article>
	</body>
</html>
