<!doctype html>

<html lang=es>
	<head>
		<title>Programción paralela</title>
		<meta charset=utf-8>
		<meta name=author content="Antonio Cepero">
		<meta name=created content="2021-06-14">
		<meta name=modified content="2021-08-11">
		<link rel=stylesheet href="estilo.css">
	</head>
	<body>
		<article>
			<header>
				<h1>Programación paralela</h1>
			</header>
			<nav class=toc>
				<ol>
					<li><a href=#recursividad>Recursividad</a></li>
					<li><a href=#creatarea>Creación de tareas</a></li>
					<li><a href=#fjframework><em>Fork-Join Framework</em></a></li>
				</ol> 
			</nav>
			<section id=Recursividad>
				<header>
					<h1 id=recursividad>Recursividad</h1>
				</header>
<p>Vamos a comenzar hablando de lo que es la recursividad. La recursividad,
que merecería un tema dedicado a la misma por sí sola, es una técnica muy
poderosa que podemos utilizar en lugar de la iteración -y Java nos
proporciona un framework que nos permite resolver problemas recursivos de
forma paralela eficientemente-.
<p>En general, la recursividad nos proporciona un modo distinto de ver las
repeticiones y, aunque las soluciones recursivas suelen ser menos eficientes
que las iterativas, para el mismo problema, en muchos casos la solución
recursiva es elegante y simple, mientras que resulta muy complejo
resolverlo iterativamente.
<p>Pero vamos a ver en qué consiste ¿Recordáis qué es una matrioska? Esas
muñecas rusas que se guardan unas dentro de otras, de forma que en el
interior de cada una de ellas hay otra más pequeña. Un algoritmo recursivo
es como un conjunto de matrioskas: se reproduce a sí mismo con ejemplares
más y más pequeños hasta que se encuentra la solución (no hay más muñecas).
<p>Imaginad la exponenciación:
<p><span class=code>X<sup>n</sup> = X * X * X * ... * X</span>
<p>que también podemos escribir como:
<p><span class=code>X<sup>n</sup> = X * X<sup>n-1</sup></span>
<p>Esto es una definición recursiva: la definición se da en términos de una versión más pequeña de sí misma.
<p>Veamos algunas definiciones:
<dl>
	<dt>Caso base</dt>
	<dd>Caso para el que la solución puede establecerse en forma no
	recursiva</dd>
	<dt>Caso general</dt>
	<dd>Caso para el que la solución se expresa en términos de una
	versión más pequeña de sí mismo</dd>
	<dt>Algoritmo recursivo</dt>
	<dd>Solución que se expresa en términos de (a) instancias más
	pequeñas de sí mismo y (b) un caso base</dd>
</dl>
<p>¿Cuándo se detiene el proceso? Cuando hemos alcanzado un caso para el
que conocemos la respuesta sin tener que volver a aplicar la recursividad.
Como hemos indicado, decimos que el caso para el que la solución se expresa
en términos de forma no recursiva es el caso base.
<p>Supongamos el caso de la exponenciación:
<pre class=code>
	double exp ( double x, int n ) {
		return x * exp(x, n-1); //¿Fin?
	}
</pre>
<p>sabemos que, cuando <em>n</em> es uno, X<sup>1</sup> es X. Ese es nuestro
caso base, aquél del que conocemos la respuesta de forma explícita:
<pre class=code>
	double exp ( double x, int n ) {
		if ( n == 1 )
			return x; // Fin
		return x * exp(x, n-1);
	}	
</pre>
<p>También podríamos haber utilizado como caso base aquél en que <em>n</em> es
cero ya que, como sabemos, cualquier número elevado a cero es uno:
<br><span class=code>X<sup>0</sup> = 1</span>
<br>todo dependerá del dominio que defináis para <em>n</em>.
<p><b>Ejercicio: Factorial de un número (N!)</b>
<br>Resolver el problema del factorial de un número N. El factorial de un
número es dicho número multiplicado por el número menos uno, por el número
menos dos, etc. El factorial de cero es uno.
<br><span class=code>N! = N * (N-1) * (N-2) * (N-3) …</span>
<br><span class=code>0! = 1</span>
<p>Los métodos de cálculo de la exponenciación y el factorial son muy
simples. En realidad, solo son útiles para entender la recursividad y,
en la práctica, usaríamos una solución iterativa, que es más sencilla
y más eficiente.
<p>Os animo a que hagáis la versión iterativa. La diferencia principal
es que la versión iterativa necesita de un par de variables (para el
acumulador y el contador), que la versión recursiva no. El bucle tampoco
es necesario en la versión recursiva, aunque requiere una condición
(o bifurcación).
<p>
<b>Ejercicio: Convertir un número decimal (base 10) a binario (base 2)</b>
<ol>
	<li>Dividir el decimal por 2
	<li>El resto obtenido será el bit de menos peso (el de más a
		la derecha)
	<li>Utilizar ahora el cociente como dividendo
	<li>Repetir, colocando cada resto a la izquierda del anterior
	<li>Hasta que el cociente sea cero
</ol>
<p>Al hacer el algoritmo, podríamos sustituir lo que dice el punto dos por:
"Si el número es impar, el bit de menos peso será 1; si es par, será 0".
Además, los puntos 1 y 2 pueden ser intercambiandos.
<p>Nota: Podéis intentar hacerlo en secuencial antes de implementar la solución recursiva
<h2>Conclusión</h2>
<p>En definitiva, <b>¿cuándo podemos usar la recursividad y cómo debemos
	hacerlo?</b>
<ol>
	<li>Asegurarse de que existe un caso base
	<li>No utilizar una estructura repetitiva (WHILE). La estructura
		básica es una selección (IF), debiendo existir, al menos,
		dos casos: el recursivo	y el base.
		Puede suceder que el caso base no haga nada,
		pero debe existir la estructura de selección.
	<li>Procurar utilizar solo variables locales al método recursivo.
		Algunos objetos pueden ser globales si se opera sobre datos
		disjuntos como, por ejemplo, los elementos de un vector.
	<li>Los parámetros formales (tamaño del problema) deben ser siempre
		por valor; no modificar objetos pasados como parámetros.
</ol>
<h2>Ejercicios</h2>
<ol>
	<li>Escribir una función recursiva que calcule el
<a target=_blank href=https://es.wikipedia.org/wiki/Sucesi%C3%B3n_de_Fibonacci#Definici%C3%B3n_recurrente>número de Fibonacci</a>
<li>Escribir un comprobador (recursivo) de
<a target=_blank href=https://dle.rae.es/pal%C3%ADndromo>palíndromo</a>
<li>Implementad el problema de las
	<a target=_blank href=https://es.wikipedia.org/wiki/Torres_de_Han%C3%B3i>torres de Hanoi</a>
(Vídeo de
	<a target=_blank href=https://www.youtube.com/watch?v=LM68IQvIo_E>Derivando</a>)
<li>Implementad el algoritmo de ordenación rápida
(<a target=_blank href=https://es.wikipedia.org/wiki/Quicksort>Quicksort</a>)
<li>Realizad el
	<a target=_blank href=https://es.wikipedia.org/wiki/Problema_de_las_ocho_reinas>problema de las ocho reinas</a>: colocad en un tablero de ajedrez 8 reinas sin que se maten entre ellas.

</ol>

			</section>
			<section id=CreaTarea>
				<header>
					<h1 id=creatarea>Creación de tareas</h1>
				</header>
<p>Supongamos que tenemos una secuencia de tareas o instrucciones S1, S2, S3…
Nuestro objetivo consiste en determinar <em>cuáles de ellas pueden ejecutarse
en paralelo y cómo podemos coordinar ese paralelismo</em>.
<p>Vamos a imaginar que tenemos un vector y que queremos sumarlos. El algoritmo
es simple: utilizamos un acumulador -<em>suma</em>, inicializado a cero- al
que vamos sumando cada uno de los elementos del vector, por ejemplo, con un
bucle. El acumulador contendrá la suma de los elementos del vector.
¿Qué sucedería si dividimos el vector en dos partes, izquierda y derecha?
Podríamos obtener la suma de los elementos de la parte izquierda como
<em>suma_izq</em> y la suma de los elementos de la parte derecha como
<em>suma_dch</em>.
La <em>suma</em> de los elementos del vector, ahora, será la misma que si
sumamos <em>suma_izq</em> y <em>suma_dch</em>.
<br><span class=code>suma_izq = suma de la parte izquierda</span>
<br><span class=code>suma_dch = suma de la parte derecha</span>
<br><span class=code>suma = suma_izq + suma_dch</span>
<br>Esto se puede hacer secuencialmente pero, ¿cómo podemos hacerlo en paralelo?
<p>Vamos a usar una notación en la que a una instrucción vamos a precederla
de la palabra <span class=palabra>ASYNC</span> que, a su vez, será una
instrucción. Esta instrucción <span class=palabra>ASYNC</span> indica que la
instrucción que la sigue debe ejecutarse de forma asíncrona. La idea de la
asincronía hace referencia a que no tiene correspondencia en el tiempo; en
nuestro concepto de paralelismo, la instrucción
<span class=palabra>ASYNC</span>
implica que puede hacerse antes que lo que la sigue, después de lo que la
sigue o, como nos interesa a nosotros, a la vez (en paralelo) que lo que
viene a continuación.
<br><span class=code><span class=palabra>ASYNC</span> suma_izq = suma de la parte izquierda</span>
<br><span class=code>suma_dch = suma de la parte derecha</span>
<br><span class=code>suma = suma_izq + suma_dch</span>
<p>Una vez que tenemos la suma de los elementos de la parte derecha, queremos
obtener la suma total (que es la instrucción que debe ejecutarse a
continuación); para ello necesitamos tener también la suma de los
elementos de la parte izquierda. Debemos fijarnos en que <em>suma_izq</em>,
al ejecutarse en forma asíncrona con lo que viene a continuación, puede
finalizar más tarde que <em>suma_dch</em> y el sistema intentaría realizar
la suma de ambas partes aun cuando la izquierda pudiera no estar
disponible. Lo que deseamos es que puedan ejecutarse
de forma asíncrona todas las tareas que no necesitan hacerlo secuencialmente
y que, de algún modo, cuando tengamos que continuar, esperemos a que todas
ellas se hayan completado. Vamos a introducir una notación
<span class=palabra>FINISH</span> que va a hacer exactamente lo que buscamos.
Si hemos asociado un <span class=palabra>ASYNC</span> a <em>suma_izq</em>
y encerramos ahora <em>suma_izq</em> y <em>suma_dch</em> entre
<span class=palabra>FINISH</span>, vamos a estar seguros de que tanto
<em>suma_izq</em> como <em>suma_dch</em> se habrán completado antes de
proceder a calcular <em>suma</em>, combinando ambos valores.
<pre class=code>
<span class=palabra>FINISH</span> {
	<span class=palabra>ASYNC</span> {
		suma_izq = suma de la parte izquierda</span>
	}
	suma_dch = suma de la parte derecha</span>
}
suma = suma_izq + suma_dch
</pre>
<p>De este modo, si tenemos una máquina con, por ejemplo, dos procesadores,
podemos ejecutar <em>suma_izq</em> en el procesador cero y <em>suma_dch</em>
en el procesador 1.
<p>Extendiéndolo a cualquier secuencia de instrucciones, podemos utilizar
<span class=palabra>ASYNC</span> en cualquier oportunidad que encontremos
de implementar paralelismo, sincronizando los valores que necesitan estar
disponibles antes de la ejecución de otra instrucción, con
<span class=palabra>FINISH</span>.

<p>
<b>Ejercicio: calcular la suma de los elementos de un vector</b>
<br>Hacerlo primero con el algoritmo sencillo que se comenta en el texto para,
a continuación, probar a hacerlo dividendo el vector en dos partes: basta con
calcular la posición del elemento mitad (la división entera por dos de la suma
de la posición del primero y la del último); la suma de la primera parte será
desde el primer elemento hasta el mitad y la de la segunda será desde el
siguiente al elemento mitad hasta el último.
<p>
<b>Ejercicio: hacerlo ahora de forma recursiva</b>
<br>El programa sería equivalente al de la ordenación rápida (éste es más
sencillo), pero solo interesa determinar el método para realizar la suma.
Consiste en crear una función que devuelva el valor de la suma de algunos de
los elementos del vector, desde una posición de inicio a otra final:
<ul>
	<li>Si el vector no tiene elementos (la posición final es menor que
		la inicial), la suma será cero; este caso no debería darse
		nunca.
	<li>Si solo hay un elemento (las posiciones inicial y final coinciden),
		la suma será el valor del elemento.
	<li>Si hay más elementos, se calcula el elemento mitad y se determinan
		las sumas parciales invocando a la función con los nuevos
		valores: inicio y mitad, siguiente a mitad y final.
</ul>
<p>Nota: El caso en el que el vector solo contiene un elemento es el caso
base y cuando hay más, el caso general.
			</section>
			<section id=FJFrameWork>
				<header>
					<h1 id=fjframework><em>Fork-Join Framework</em></h1>
				</header>
<p>Como decíamos, los algoritmos recursivos son más ineficientes que sus
homólogos iterativos pero, en un ambiente de paralelismo, la recursividad
puede ser elegante y también eficiente. En un entorno paralelo, la
recursividad proporciona un estilo natural de describir algoritmos sin las
desventajas que se producen en la computación secuencial.
<p>El <i>framework <b>fork-join</b></i> es uno de los modos más populares de
explotar el paralelismo de Java. Se basa, fundamentalmente, en las clases
<a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/RecursiveAction.html>RecursiveAction</a>
y
<a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/RecursiveTask.html>RecursiveTask</a>.
Ambas son extensiones de una clase
<a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ForkJoinTask.html>ForkJoinTask</a>,
cuya documentación podéis consultar, que permite resolver problemas mediante
la técnica de divide y vencerás, de forma eficiente, explotando el paralelismo.
La forma más simple de utilización es a través de los métodos:
<ul>
<li><span class=metodo>compute</span>, en el que construimos el algoritmo
recursivo,
<li><span class=metodo>fork</span>, con el que crearemos procesos
asíncronos (equivalente al <span class=palabra>ASYNC</span>),
<li>y <span class=metodo>join</span>, con el que esperaremos a la finalización
del proceso asíncrono (equivalente al <span class=palabra>FINISH</span>).
</ul>
<p>Siguiendo con nuestro ejemplo para la suma de los elementos de un vector,
creamos una clase Suma que contiene, como componentes de estado, un vector
<em>v</em> y unos valores de inicio (<em>izq</em>) y de finalización
(<em>dch</em>). También, un valor <em>suma</em> que almacenará la suma de
los elementos del vector desde <em>izq</em> hasta <em>dch</em>. Es decir,
el vector puede contener muchos elementos pero a nosotros solo nos
interesará aquí la suma desde un elemento cualquiera (cuya posición en el
vector denominamos <em>izq</em>) hasta otro (cuya posición denominamos
<em>dch</em>).
<pre class=code>
class Suma {
	double[] v;
	int izq, dch;
	double suma;
}
</pre>
<p>Podemos tener un constructor que almacene los valores del vector, posición
de inicio y fin. Podríamos hacer que este constructor calculara el valor de
la suma pero, en su lugar, vamos a crear un método específico.
<pre class=code>
Suma ( double[] v, int izq, int dch );
</pre>
<p>El método con el que vamos a calcular el valor de la suma (de manera
recursiva) se va a denominar <span class=metodo>compute</span>. ¿Cuál es
nuestro caso base? Recordando el ejercicio anterior, si ambos valores (de
posición) son el mismo, la suma corresponderá al valor del elemento en esa
posición.
¿Cuál es el método recursivo? Dividir el vector en dos subvectores
y calcular la suma para cada uno de ellos.
Para hacerlo, calculamos el valor de la posición intermedia <em>m</em>: la
parte izquierda irá desde la posición inicial (<em>izq</em>) hasta esta
posición intermedia (<em>m</em>); la parte derecha comenzará en la posición
siguiente a la intermedia (<em>m+1</em>) y terminará en la posición final
(<em>dch</em>).
<pre class=code>
void compute() {
	if ( izq == dch )
		suma = vector[izq];
	else {
		int m = (izq + dch) / 2;
	}
}
</pre>
<p>Volvemos a tener el mismo caso que estábamos construyendo pero con dos
secciones diferentes del vector: creamos dos nuevas instancias (<em>I</em>,
<em>D</em>) iguales a la que contiene este método, con sus respectivos
valores de inicio y fin. Ejecutamos a continuación el método compute para
cada una de esas instancias y la suma de este objeto será igual la suma de
las correspondientes a cada instancia I y D.
<pre class=code>
Suma I = new Suma(v, izq, m);
Suma D = new Suma(v, m+1, dch);
I.compute();
D.compute();
suma = I.suma + D.suma;
</pre>
<p>Como ya quedó claro, el cálculo de la suma de la parte izquierda es
totalmente independiente de la suma de la parte derecha, por lo que podemos
calcular ambas de manera asíncrona. Esto nos permite pensar que, por ejemplo,
podríamos realizar el cálculo de la suma de <em>I</em> de forma asíncrona
(<span class=palabra>ASYNC</span> I.compute();): se ejecutaría en otro
procesador si nuestra máquina es multiprocesador. Pero debemos esperar a
que dicha suma se haya realizado antes de utilizarla, junto con la de
<em>D</em>, por lo que deberá existir un <span class=palabra>FINISH</span>
que englobe a ambos compute. Finalmente, como ambas instancias habrán
calculado su propia suma, podremos obtener la suma de este objeto.
<pre class=code>
void compute() {
	if ( izq == dch )
		suma = vector[izq];
	else {
		int m = (izq + dch) / 2;
		Suma I = new Suma(v, izq, m);
		Suma D = new Suma(v, m+1, dch);
		<span class=palabra>FINISH</span> {
			<span class=palabra>ASYNC</span> {
				I.compute();
			}
			D.compute();
		}
		suma = I.suma + D.suma;
	}
}
</pre>
<p>Convetirlo en código Java es sencillo haciendo uso del
<em>FJ Framework</em>. Nuestra clase no cambia, salvo porque debe extender
a la clase
<a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/RecursiveAction.html>RecursiveAction</a>.
Como ya se ha comentado, el equivalente al <span class=palabra>ASYNC</span>
lo encontramos en el método <span class=metodo>fork</span>. La invocación al
método <span class=metodo>fork</span> de la clase que extiende a
<span class=clase>RecursiveAction</span> crea una nueva instancia de ejecución
que invoca la ejecución del método <span class=metodo>compute</span>. Después,
para esperar a que dicho valor esté disponible, invocamos al método
<span class=metodo>join</span> de la clase: si la ejecución de
<span class=metodo>compute</span> ya hubiera terminado, continuará la
ejecución pero, en caso contrario, bloqueará la ejecución del proceso
actual hasta que el otro proceso finalice: hasta que termine la ejecución
del <span class=metodo>compute</span> de <em>I</em>.
<pre class=code>
class Suma <span class=modificado>extends RecursiveAction</span> {
	double[] v;
	int izq, dch;
	double suma;
 	void compute() {
		if ( izq == dch )
			suma = vector[izq];
		else {
			int m = (izq + dch) / 2;
			Suma I = new Suma(v, izq, m);
			Suma D = new Suma(v, m+1, dch);<span class=modificado>
			I.fork();
			D.compute();
			I.join();</span>
			suma = I.suma + D.suma;
		}
	}
}
</pre>
<p>En lugar de utilizar el par <em>fork-join</em>, resulta posible también
utilizar el método
<a class=metodo href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ForkJoinTask.html#invokeAll(java.util.concurrent.ForkJoinTask,java.util.concurrent.ForkJoinTask)>invokeAll</a>,
que se encarga por si mismo de lanzar la ejecución de ambas tareas y esperar
a su finalización, antes de proseguir.
<pre class=code>
...
Suma I = new Suma(v, izq, m);
Suma D = new Suma(v, m+1, dch);<span class=modificado>
invokeAll(I, D);</span>
suma = I.suma + D.suma;
...
</pre>
<p>Tal cual lo hemos creado hasta este momento, el programa es totalmente
funcional y, si creamos un objeto de nuestra
clase <em>Suma</em> e invocamos su método <em>compute</em>, éste se
ejecutará haciendo uso del paralelismo.
<pre class=code>
import java.util.concurrent.RecursiveAction;

public class SumaVector {

	static final int MAX_VECTOR = 1000000;

	static class SumaFJ extends RecursiveAction {
		double suma;
		int ini, fin;
		double[] vector;
		
		SumaFJ ( double[] v, int i, int f ) {
			vector = v;
			ini = i;
			fin = f;
		}
		
		 protected void compute ( ) {
			if ( ini == fin ) suma = vector[ini];
			else {
				int mitad = (ini + fin) / 2;
				SumaFJ izq = new SumaFJ(vector, ini, mitad);
				SumaFJ dch = new SumaFJ(vector, mitad+1, fin);
				izq.fork(); dch.compute(); izq.join();
				suma = dch.suma + izq.suma;
			}
		}
	}
	
	public static void main ( String[] args ) {
		double[] vector = new double[MAX_VECTOR];
		for ( int i = 0; i < MAX_VECTOR; i++ )
			vector[i] = Math.random();
		SumaFJ aux = new SumaFJ(vector, 0, vector.length-1);
		aux.compute();

	}
}
</pre>
<p>El <em>framework fork-join</em> se ejecuta, por defecto, en un servicio
de ejecución denominado
<a class=clase target=_blank
	href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ForkJoinPool.html>ForkJoinPool</a>.
No vamos, de momento, a entrar en cómo funciona. Nos basta con pensar que
hay un servicio con el que vamos a poder trabajar. Podemos también utilizarlo,
explícitamente: en algún punto de nuestro código invocaremos una instancia
de la clase que extiende el <span class=clase>RecursiveAction</span> como
muestra el código siguiente:
<pre>
class Programa {
    ...
    class Ejemplo extends RecursiveAction {
        ...
    }
    ...
        ForkJoinPool
	    .commonPool()
            .invoke(ra = new Ejemplo(...));
        // obtenemos ra.valor
    ...
    main( ) {
        ...
    }
}
</pre>
<p>Este <span class=clase>ForkJoinPool</span> tiene un método
<span class=metodo>commonPool</span> que nos devuelve una referencia
al grupo de hilos estándar, apropiado para la mayoría de las aplicaciones.
Podemos también enviar nuestra tarea, con el método
<span class=metodo>invoke</span> para que la ejecute en paralelo.


			</section>
			<footer>
<nav class=pie>
	<a class=previo href=03_progsec.html>Programación segura</a>
        <a class=inicio href=index.html>Índice</a>
        <a class=siguiente></a>
</nav>
		<p>Programación de servicios y procesos</p>
			</footer>
		</article>
	</body>
</html>
