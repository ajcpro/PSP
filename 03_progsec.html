<!doctype html>

<html lang=es>
	<head>
		<title>Programación segura</title>
		<meta charset=utf-8>
		<meta name=author content="Antonio Cepero">
		<meta name=created content="2021-06-11">
		<meta name=modified content="2021-08-18">
		<link rel=stylesheet href="estilo.css">
	</head>
	<body>
		<article>
			<header>
				<h1>Programación segura</h1>
			</header>
			<nav class=toc>
				<ol>
					<li><a href=#intro>Introducción</a></li>
					<li><a href=#amenaza>Amenazas</a></li>
					<li><a href=#situacion>Situación de error</a></li>
					<li><a href=#excepciones>Excepciones en Java</a></li>
				</ol> 
			</nav>
			<section id=Introduccion>
				<header>
					<h1 id=intro>Introducción</h1>
				</header>
<p>Define la Real Academia de la Lengua
<a target=_blank href=https://dle.rae.es/seguridad>seguridad</a> como:
<em>cualidad de seguro</em>. A su vez, reza que
<a target=_blank href=https://dle.rae.es/seguro>seguro</a> es:
<em>libre y exento de riesgo</em>, siendo el
<a target=_blank href=https://dle.rae.es/riesgo>riesgo</a> la posibilidad
de que suceda o no un daño, algo que pueda causar un perjuicio. Es decir,
que para que algo sea seguro, la seguridad consiste en procurar que no
reciba daño.
Podríamos definir la seguridad informática como una disciplina que se ocupa
de diseñar las normas, procedimientos, métodos y técnicas destinados a
conseguir un sistema de información seguro y confiable.
<p>De los sistemas informáticos, ya sean sistemas operativos, servicios o
aplicaciones, se dice que son seguros si cumplen las siguientes
características: 
<dl>
	<dt>Confidencialidad.</dt>
	<dd>Requiere que la información sea accesible únicamente para las
	entidades autorizadas.</dd>
	<dt>Integridad.</dt>
	<dd>Requiere que la información sólo pueda ser modificada por las
	entidades autorizadas. La modificación incluye escritura, cambio,
	borrado, creación y reenvío de los mensajes transmitidos.</dd>
	<dt>Disponibilidad.</dt>
	<dd>Requiere que los recursos del sistema informático estén
	disponibles para las entidades autorizadas cuando los necesiten.</dd>
	<dt>No repudio.</dt>
	<dd>Ofrece protección a un usuario frente a otro que niegue
	posteriormente su autoría o que se realizó cierta comunicación.
	El no repudio
	de origen protege al receptor de que el emisor niegue haber enviado
	el mensaje, mientras que el no repudio de recepción protege al emisor
	de que el receptor niegue haber recibido el mensaje. Las firmas
	digitales constituyen el mecanismo más empleado para este fin.</dd> 
</dl>

			</section>
			<section id=Amenazas>
				<header>
					<h1 id=amenazas>Amenazas</h1>
				</header>
<p>En sistemas de información se entiende por
<a target=_blank href=https://es.wikipedia.org/wiki/Seguridad_informática>amenaza</a>
la presencia de uno o
más factores de diversa índole (personas, máquinas o sucesos) que -de
tener la oportunidad- atacarían al sistema produciéndole daños
aprovechándose de su nivel de vulnerabilidad. Hay diferentes tipos de
amenazas de las que hay que proteger al sistema, desde las físicas como
cortes eléctricos, fallos del hardware o riesgos ambientales hasta los
errores intencionados o no de los usuarios, la entrada de software malicioso
(virus, troyanos, gusanos) o el robo, destrucción o modificación de la
información.
<p>En función del tipo de alteración, daño o intervención que podrían
producir sobre la información, las amenazas se clasifican en cuatro grupos:
<dl>
	<dt>De interrupción.<dt>
	<dd>El objetivo de la amenaza es deshabilitar el acceso a la
		información; por ejemplo, destruyendo componentes físicos
		como el disco duro, bloqueando el acceso a los datos, o
		cortando o saturando los canales de comunicación.</dd>
	<dt>De interceptación.</dt>
	<dd>Personas, programas o equipos no autorizados podrían acceder
		a un determinado recurso del sistema y captar información
		confidencial de la organización, como pueden ser datos,
		programas o identidad de personas.</dd>
	<dt>De modificación.</dt>
	<dd>Personas, programas o equipos no autorizados no solamente
		accederían a los programas y datos de un sistema de
		información sino que ade­más los modificarían. Por ejemplo,
		modificar la respuesta enviada a un usuario conectado o
		alterar el comportamiento de una aplicación instalada.</dd>
	<dt>De fabricación.</dt>
	<dd>Agregarían información falsa en el conjunto de información
		del sistema.</dd>
</dl>
<p>Según su origen las amenazas se clasifican en:
<dl>
	<dt>Accidentales.</dt>
	<dd>Accidentes meteorológicos, como incendios o inundaciones,
	fallos en
	los equipos, en las redes, en los sistemas operativos o en el
	software y errores humanos.</dd>
	<dt>Intencionadas.</dt>
	<dd>Son debidas siempre a la acción humana, como la introducción de
	software malicioso -malwar - (aunque este penetre en el sistema
	por algún procedimiento automático, su origen es siempre humano),
	intrusión informática (con frecuencia se produce previanebte a la
	introducción de malware en los equipos), robos o hurtos. Las
	amenazas intencionadas pueden tener su origen en el exterior de la
	organización o incluso en el personal de la misma.</dd>
</dl>
			</section>
			<section id=Situacion>
				<header>
					<h1 id=situacion>Situación de error</h1>
				</header>
<p>Las situaciones de error se producen por diferentes causas, como una
<em>implementación incorrecta</em>, cuando el código no se ajusta a las
especificaciones, una <em>petición de objeto inapropiada</em>, como un
índice no válido (en un vector) o una referencia nula, o que el estado
de un objeto sea inapropiado o inexistente.
<p>Pero no siempre es debido a un error de programación. Pueden producirse
errores en el entorno, como la introduccion errónea de los datos o que se
produzca una interrupción en las comunicaciones; también, durante el
procesamiento de ficheros, como que no exista el archivo al que deseamos
acceder o que los permisos de acceso sean inadecuados.
<h2>Programación defensiva</h2>
Estos acontecimientos provocan que, para garantizar el correcto funcionamiento
de las aplicaciones, deba utilizarse la técnica de la
<a target=_blank href=https://es.wikipedia.org/wiki/Programaci%C3%B3n_defensiva>programación defensiva</a>,
que conlleva la incorporación de un gran número de comprobaciones, con la
consiguiente merma en rendimiento.
<p>Pero, ¿qué cosas deben ser comprobadas? ¿Debe tratarse el fallo en el 
punto en que se produce o se informa de los errores al código que invocó
a aquél en que se ha producido? ¿cómo debe tratarse el error? Si el error
no se trata, ¿cómo se informa del mismo? ¿Puede el código anticiparse al
fallo? Y si lo hace, ¿cuándo?
<p>Veamos un ejemplo sencillo. Supongamos que tenemos una agenda;
identificamos las entradas en la misma mediante algún tipo de clave que
podemos utilizar para localizarlas. Queremos borrar un registro: localizamos
el mismo a través de su clave y, a continuación, lo eliminamos:
<pre style=code>
	public void eliminar ( String clave ) {
		Contacto contacto = agenda.buscar(clave);
		agenda.borrar(contacto);
	}
</pre>
<p>Se produce un error: por ejemplo, que el registro no existe. ¿Quién tiene
la culpa? En general, es preferible anticiparse a quejarse.
<h3>Comprobación de clave</h3>
<p>Los argumentos son una vulnerabilidad:
<ul>
	<li>Inicializan el estado en un constructor
	<li>Contribuyen al comportamiento en un método
</ul>
<p>La comprobación de los argumentos es una medida defensiva:
<pre style=code>
	public void eliminar ( String clave ) {
		Contacto contacto;
		if ( agenda.existe(clave) ) {
			contacto = agenda.buscar(clave);
			agenda.borrar(contacto);
		}
	}
</pre>
<p>En este caso, comprobamos si existe el registro que deseamos eliminar
antes de proceder al borrado.
<h3>Información del error</h3>
<p>El modelo clásico para informar de que se ha producido un error es la
devolución de un diagnóstico. Por ejemplo, el método puede ser implementado
como una función booleana que devuelva verdadero solo si la operación se ha
realizado con éxito:
<pre style=code>
	public boolean eliminar ( String clave ) {
		Contacto contacto;
		if ( agenda.existe(clave) ) {
			contacto = agenda.buscar(clave);
			agenda.borrar(contacto);
			return true;
		} else
			return false;
	}
</pre>
<p>La salida de la función deberá ser comprobada por el método que la invocó:
<pre style=code>
	if ( ! objeto.metodo(parametros) ) {
		// tratar error
	} else {
		// código normal
	}
</pre>
<p>Este es un método sencillo pero que complica el código innecesariamente
debido a la anidación. Además, pueden producirse otros tipos de errores de
ejecución que no son capturables.
<p>Los lenguajes modernos, especialmente los que soportan la programación
orientada al objeto, incorporan un mecanismo de gestión del error a través
de las denominadas
<a target=_blank href=https://es.wikipedia.org/wiki/Manejo_de_excepciones>excepciones</a>.
<p>La estructura del código en este caso, como antes, tiene dos partes, la
del método invocado, en el que se produce el error, y el que invoca, en el
que el error puede ser tratado. En el primero, cuando se produce el error,
bien sea porque se incumple alguna condición o porque hay algún error en el
entorno, se indica la excepción y se finaliza la ejecución del método. En el
segundo, se codifican dos partes diferenciadas: la secuencia de ejecución
normal, por un lado, y el tratamiento del error, por el otro.
			</section>
			<section id=Excepciones>
				<header>
					<h1 id=excepciones>Excepciones en Java</h1>
				</header>
<p>El lenguaje de programación
<a target=_blank href= https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html>Java</a>
hace uso de las excepciones para indicar cuándo se ha producido un error.
Siguiendo la filosofía del lenguaje, una excepción es un objeto; el objeto
será una instancia de la clase
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Throwable.html>Throwable</a>
o de alguna de sus subclases, que transporta información desde el punto en
el que se ha producido el error. Como subclases podemos encontrar
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Error.html>Error</a> y
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Exception.html>Exception</a>. La primera es utilizada por la
propia máquina virtual de Java y hace referencia a errores irrecuperables
que no se tratan. La segunda hace referencia a errores que el programador
debería tratar.
<p>Así pues, nuestras
<a target=_blank href=https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html>excepciones</a>,
serán instancias de la clase <em>Exception</em>. Además, de éstas,
existen también dos tipos: las que no requieren comprobación y las que
deben comprobarse. Las primeras se corresponden con errores de ejecución
durante el funcionamiento normal de la JVM y se identifican con la superclase
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/RuntimeException.html>RuntimeException</a>. El resto son
conocidas como <em>checked exceptions</em>.
<div class=image id=03_01 style="width:80%;margin-left:10%">
	<img src=imagenes/03_01_1520193587846.jfif style="width:100%"
	     alt="Jerarquia de excepciones en Java">
	<p class=caption>Jerarquia de excepciones en Java<br>
	Imagen tomada de la página de
	<a target=_blank href=https://www.linkedin.com/pulse/java-exception-basics-daniel-chiuratto-seabra?articleId=6205828205065105408>Daniel Chiuratto Seabra</a>
</div>

<h2>Lanzamiento de excepciones</h2>
<p>Cuando se produce un error y se genera una excepción, se dice que ésta se
lanza: <em>throw</em>. Cualquier código es susceptible de lanzar una
excepción, sea el entorno de trabajo de la JVM, una biblioteca o tu propio
código. Ya hemos comentado que una excepción será una instancia de alguna
subclase de <span class=clase>Throwable</span>.
<p>Cuando la excepción se produce, el método que está ejecutándose se detiene
prematuramente y no devuelve valor alguno. Además, el control no vuelve al
punto desde el que el método fue invocado: se dirige al código que gestiona
la excepción o se re-lanza hacia un método anterior, que pueda gestionar el
error. Por supuesto, resulta posible <em>capturarla</em> (tener un punto en el
código para el tratamiento de la excepción) y no tratarla (gestionar el
error); sería conveniente, en cualquier caso, proporcionar algún tipo de
mensaje o notificación.
<p>Pero, ¿cómo indicamos en nuestro código que se ha producido una excepción?
<ol>
	<li>Construir un objeto de excepción. Una excepción, como hemos
		indicado es una clase; por tanto, usaremos el operador
		<span class=operador>new</span>.
	<li>El lanzamiento de la excepción se lleva a cabo con el operador
		<a class=operador target=_blank href=https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.18>throw</a>. Lo habitual es realizar
		ambas operaciones en una única instrucción
		<br><span class=code><b>throw</b> new ExceptionType();</span>
	<li>Documentar que puede producirse la excepción y por qué. Se incluye
		en la documentación Javadoc del método:
		<br><span class=code style="white-space:normal">
		<b>@throws</b> ExceptionType
		               causa_que_provoca_el_lanzamiento</span>
</ol>
<h3>Excepciones <i>Runtime</i></h3>
<p>Este tipo de excepciones está reservado para indicar el uso incorrecto de
algún API como, por ejemplo, que un método trate de acceder a un miembro de
un objeto a través de una referencia a <em>null</em>. Estas excepciones,
además, pueden producirse en cualquier lugar de un programa y ser muy
numerosas. Tener que añadir código para su tratamiento reduciría la claridad
del programa por lo que no requieren ser tratadas y por ello, en ocasiones,
los programadores pueden sentirse tentados a utilizar solo este tipo.
En general, no deben lanzarse excepciones de este tipo, simplemente, por no
tener que tratarlas. La idea básica es: utilízala si el cliente no puede
hacer nada para recuperarse del error; si no, utiliza una <em>checked
exception</em>.
<p>Un caso cómún es el que hemos comentado antes: el uso incorrecto del API.
Recordemos el ejemplo de la agenda:
<pre class=code>
public Contacto datos ( String clave ) {
	if ( clave == null )
		throw new <a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/NullPointerException.html>NullPointerException</a>(
			 "Clave nula en datos");
	if ( clave.length() == 0 )
		throw new <a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/IllegalArgumentException.html>IllegalArgumentException</a>(
			 "Clave vacía en datos");
	return agenda.buscar(clave);
}
</pre>
<p>Vemos dos situaciones de error producidas, en el primer caso, porque la
referencia que recibe la función es <em>null</em>; en el segundo, la clave
está vacía. Si no se produce ninguna de esas situaciones, el método
prosigue con normalidad. Podemos apreciar también que hemos añadido un
argumento al constructor de la excepción: permite añadir un mensaje que puede
ser recuperado posteriormente con el método
<a class=metodo target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Throwable.html#getMessage()>getMessage</a>().
<pre class=code>
public Contacto ( String nombre, String telefono ) {
	if ( nombre == null ) nombre = "";
	if ( telefono == null ) telefono = "";
	if ( nombre.length() == 0
	  || telefono.length() == 0 )
		throw new IllegalArgumentException(
			 "Error creando contacto");
	this.nombre = nombre;
	this.telefono = telefono;
}
</pre>
<p>Ejemplo similar al anterior: al crear un nuevo contacto necesitamos tener
sus dos componentes ya que, si uno de ellos no está disponible, la instancia
no puede existir. 

<h3>Cláusula <em>throws</em></h3>
<p>Si bien las excepciones que no necesitan ser comprobadas tampoco necesitan
ser declaradas, el resto sí. Bien sea porque el método genera la excepción,
bien porque invoca a otro método que la genera y éste no la trata, debe
especificar que puede lanzar la excepción.
<p>Para indicar que un método puede (re)lanzar una o más excepciones debemos
añadir la <em>cláusula throws</em> a la firma del método:
<pre class=code>
public void metodo ( Object parametro )
	throws <a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/IOException.html>IOException</a>, <a class=clase target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/IndexOutOfBoundsException.html>IndexOutOfBoundsException</a> {
	// Código que puede provocar la excepción
	// pero no la gestiona
}
</pre>
<p>La <em>cláusula throws</em> contiene la palabra reservada <em>throws</em>,
seguida de una lista, separada por comas, de todas las excepciones que pueden
ser lanzadas por el método. Se añade a la firma del método, es decir, se
coloca tras la lista de argumentos y antes del bloque que define el ámbito
del método.
<p>Por último, la excepción <span class=clase>IndexOutOfBoundsException</span>
es una <em>unchecked excepction</em>, por lo que no tiene que se comprobada;
ello supone que no es obligatorio incluirla en la <em>cláusula throws</em>,
pudiendo haber escrito:
<pre class=code>public void metodo ( Object parametro )
	throws IOException {
	...
</pre>

<h2>Tratamiento de las excepciones</h2>
<p>Hasta ahora sabemos que las excepciones pueden ser lanzadas por la propia
JVM, por código de bibliotecas que estamos utilizando o, incluso, por nuestro
propio código, utilizando <em>throw</em>.
<p>Sabemos también que podemos no tratarlas y dejar que sea el método que
invocó al que se está ejecutando actualmente el que lo haga; para ello
utilizamos <em>throws</em>, si la excepción debe ser comprobada. Este es el
primer modo posible de tratar una excepción: la <b>propagación</b>. La
excepcíón irá siendo lanzada a los métodos invocantes hasta alcanzar uno que
la trate o, en caso de que ningún método la gestione, lo hará la JVM
imprimiendo la traza de la pila de llamadas del programa y finalizándolo.
<p>El método que sea responsable de tratar la excepción lo hará a través de lo
que se conoce como bloque <em><b>try-catch</b></em>, que java denomina
sentencia <a class=operador target=_blank href=https://docs.oracle.com/javase/specs/jls/se14/html/jls-14.html#jls-14.20>try</a>:
<pre class=code>
try {
	// código que puede generar error
} catch ( ExceptionType e ) {
	// código que gestiona el error
}
</pre>
<p>Vemos que, en realidad, se compone de dos bloques: el bloque
<em><b>try</b></em> y el bloque <em><b>catch</b></em>.
<p>El marcado como <em>código que puede generar error</em> corresponderá a
una o más sentencias susceptibles de que, al ejecutarse, generen alguna
excepción. Si sucede dicha excepción dentro del bloque <em><b>try</b></em>,
ésta es tratada por el gestor asociado al mismo: el bloque
<em><b>catch</b></em>.
<p>El ámbito del bloque <em><b>catch</b></em> está restringido al bloque
<em><b>try</b></em> que lo precede y se especifica como si se tratara de un
método llamado <em>catch</em>. Proporciona soporte al tipo de excepción
indicado por su argumento que, claro está, debe ser una clase que hereda de
<span clase=class>Throwable</span> a cuya instancia hemos denominado
<em>e</em>. El marcado como <em>código que gestiona el error</em>
corresponderá a una o más sentencias para el tratamiento de la excepción,
pudiendo hacer referencia a la misma a través del identificador <em>e</em>.
<p>Aunque se ha comentado antes que, al menos, sería conveniente imprimir un
mensaje o notificar el error de algún modo, tratar las excepciones tiene como
objetivo recuperarse de un error, solicitar asistencia al usuario para que
tome una decisión o propagar el error utilizando lo que se conoce como
<b>excepciones encadenadas</b> (<em><b>chained exceptions</b></em>), que
veremos más adelante.
<p>Resulta posible tratar más de una excepción, que pueda producirse dentro de
un bloque <em><b>try</b></em>, encadenando múltiples bloques
<em><b>catch</b></em>, uno por excepción:
<pre class=code>
try {
	// código que puede generar error
} catch (ExceptionType2 e2) {
	// código que gestiona e2
} catch (ExceptionType1 e1) {
	// código que gestiona e1
}
</pre>
<p>En caso de producirse una excepción y que ésta se corresponda con alguna de
las indicadas en los difrentes <em><b>catch</b></em>, se elige el bloque de la
que aparezca primero y se ejecuta. Si el bloque finaliza correctamente, la
sentencia <span class=operador>try</span> finaliza correctamente; en caso
contrario, también la sentencia <span class=operador>try</span> finalizará
con el error del bloque <em><b>catch</b></em>. Si la excepción no se
corresponde con ninguna de las indicadas en las cláusulas
<em><b>catch</b></em>, se propagará.
<p>Resulta posible indicar excepciones genéricas, como
<span class=clase>Throwable</span> o la propia
<span class=clase>Exception</span>. También, especificar simultáneamente, en
diferentes cláusulas <em><b>catch</b></em>, una excepción genérica y otra/s
que sea/n subclase/s suya/s. En este caso, cuanto más genérica sea, deberá
especificarse más tarde; se elige el bloque correspondiente a la que antes
aparece en el código, de las que coinciden con el error que se ha producido.
<p>Una cláusula <em><b>catch</b></em> puede gestionar más de un tipo de
excepción. Esto resulta conveniente cuando el código del bloque a ejecutar
para tratar más de un error es el mismo. La forma de hacerlo es especificando
la lista de excepciones que puede tratar, separadas por el símbolo de la barra
vertical (<em>|</em>), en lugar de una única excepción:
<pre class=code>
try {
	// código que puede generar error
} catch (ExceptionTypeA|ExceptionTypeB e) {
	// código que gestiona ambos tipos de error
}
</pre>

<h3>Claúsula <em>finally</em></h3>
<p>Si se especifica, el bloque <em><b>finally</b></em> se ejecuta
<b>siempre</b>, una vez ha finalizado el bloque <em><b>try</b></em>. Se
especifica tras el último <em><b>catch</b></em>:
<pre class=code>
try {
	// código que puede generar error
} catch (ExceptionType e) {
	// código que gestiona el error
} finally {
	// código que se ejecuta siempre
}
</pre>
<p>Que siempre se ejecute garantiza que lo hará si el bloque
<em><b>try</b></em> termina correctamente pero también si se produce un error.
También si se ejecuta un bloque <em><b>catch</b></em>, termine correctamente
o no. Los únicos casos en los que no se puede garantizar que se ejecutará es
en aquellos en los que la JVM deje de funcionar antes de ejecutarlo: mientras
está en ejecución el bloque <em><b>try</b></em> o uno <em><b>catch</b></em>.
O en un programa multihilo, si el hilo en ejecución es interrumpido o
finalizado, análogamente, antes de entrar en el bloque <em><b>finally</b></em>.
<p>La claúsula <em><b>finally</b></em>, además de el tratamiento de las
excepciones, permite al programador introducir código de limpieza de recursos
que, de otro modo, podría ser olvidado; por ejemplo, por usar un
<span class=operador>return</span>. Es por ello una buena práctica
<b>siempre</b> incluirlo, ya sea para cerrar ficheros o cuaquier otro tipo de
código de limpieza, aun cuando no se espere que haya excepciones (y no
incluyamos ningún bloque <em><b>catch</b></em>).

<h3>Métodos generales</h3>
<p>Además del ya comentado <span class=metodo>getMessage</span>(), y los
constructores de la clase <span class=clase>Throwable</span>, con y sin
mensaje, un par de métodos más suelen ser muy útiles:
<dl>
	<dt>
<a class=metodo
	href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Throwable.html#getMessage()>getMessage()</a></dt>
	<dd></dd>
<a class=metodo
	href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Throwable.html#toString()>toString</a></dt>
	<dd></dd>
</dl>

<h2>Excepciones de usuario</h2>
<p>A la hora de determinar qué excepción debemos lanzar si se ha producido un
error, el API de Java nos proporciona una gran cantidad de ellas pero, si ello
permite proporcionar una mejor información sobre el error, también resulta
posible definir nuestros propios tipos de <span class=clase>Exception</span>.
Podemos extender tanto <span class=clase>Exception</span> como
<span class=clase>RunTimeException</span>, según necesitemos que sean o no
comprobadas.
<pre class=code>
public Class MiException extends Exception {
	public MiException ( ) {
		super();
	}
	public MiException ( String msg ) {
		super(msg);
	}
}
</pre>
<p>El ejemplo anterior es lo más simple que podemos hacer para crear nuestra
propia excepción: creamos una clase que hereda de
<span class=clase>Exception</span> y, en el constructor, invocamos
el de la superclase.
<p>Pero estamos creando una nueva clase, por lo que ésta puede tener más
funcionalidades, además de las que nos proporciona
<span class=clase>Exception</span>.
<pre class=code>
public Class MiException extends Exception {
	private String clave;
	public MiException ( ) {
		clave = "";
	}
	public MiException ( String clave ) {
		super();
		this.clave = clave;
	}
	public String getClave ( ) {
		return clave;
	}
	public String toString ( ) {
		return "La clave es: " + clave;
	}
}
</pre>
<p>En este caso hemos modificado la funcionalidad, por ejemplo, redefiniendo
el método <span class=metodo>toString</span>(): en caso de imprimir el objeto
al que hemnos asignado un nombre en el bloque <em><b>catch</b></em>, se
escribirá esa frase. Por supuesto, podríamos haber creado un nuevo constructor
al que, en lugar de pasarle una cadena, podríamos haberle pasado un número o
la referencia al objeto que ha causado el error, etc. Y, por supuesto, podemos
crear subclases que definan mejor el tipo de error de usuario que queremos
especificar.
<p style="font-size:1.2em">Para una mejor legibilidad del código, añadiremos
<b>siempre</b> el sufijo <b>Exception</b> a las excepciones que creemos
nosotros y a las subclases de éstas.
			</section>
			<a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html>Manual</a>
			<footer>
<nav class=pie>
        <a class=previo href=02_multip.html>Programación multiproceso</a>
        <a class=inicio href=index.html>Índice</a>
        <a class=siguiente href=04_progpar.html>Programación paralela</a>
</nav>
		<p>Programación de servicios y procesos</p>
			</footer>
		</article>
	</body>
</html>
