<!doctype html>

<html lang=es>
	<head>
		<title>Programción segura</title>
		<meta charset=utf-8>
		<meta name=author content="Antonio Cepero">
		<meta name=created content="2021-06-11">
		<meta name=modified content="2021-07-21">
	</head>
	<body>
		<article>
			<header>
				<h1>Programación segura</h1>
			</header>
			<nav class=toc>
				<ol>
					<li><a href=#intro>Introducción</a></li>
					<li><a href=#amenaza>Amenazas</a></li>
					<li><a href=#situacion>Situación de error</a></li>
					<li><a href=#excepciones>Excepciones en Java</a></li>
				</ol> 
			</nav>
			<section id=Introduccion>
				<header>
					<h1 id=intro>Introducción</h1>
				</header>
<p>Define la Real Academia de la Lengua
<a target=_blank href=https://dle.rae.es/seguridad>seguridad</a> como:
<em>cualidad de seguro</em>. A su vez, reza que
<a target=_blank href=https://dle.rae.es/seguro>seguro</a> es:
<em>libre y exento de riesgo</em>, siendo el
<a target=_blank href=https://dle.rae.es/riesgo>riesgo</a> la posibilidad
de que suceda o no un daño, algo que pueda causar un perjuicio. Es decir,
que para que algo sea seguro, la seguridad consiste en procurar que no
reciba daño.
Podríamos definir la seguridad informática como una disciplina que se ocupa
de diseñar las normas, procedimientos, métodos y técnicas destinados a
conseguir un sistema de información seguro y confiable.
<p>De los sistemas informáticos, ya sean sistemas operativos, servicios o
aplicaciones, se dice que son seguros si cumplen las siguientes
características: 
<dl>
	<dt>Confidencialidad.</dt>
	<dd>Requiere que la información sea accesible únicamente para las
	entidades autorizadas.</dd>
	<dt>Integridad.</dt>
	<dd>Requiere que la información sólo pueda ser modificada por las
	entidades autorizadas. La modificación incluye escritura, cambio,
	borrado, creación y reenvío de los mensajes transmitidos.</dd>
	<dt>No repudio.</dt>
	<dd>Ofrece protección a un usuario frente a otro que niegue
	posteriormente que se realizó cierta comunicación. El no repudio
	de origen protege al receptor de que el emisor niegue haber enviado
	el mensaje, mientras que el no repudio de recepción protege al emisor
	de que el receptor niegue haber recibido el mensaje. Las firmas
	digitales constituyen el mecanismo más empleado para este fin.</dd> 
	<dt>Disponibilidad.</dt>
	<dd>Requiere que los recursos del sistema informático estén
	disponibles para las entidades autorizadas cuando los necesiten.</dd>
</dl>

			</section>
			<section id=Amenazas>
				<header>
					<h1 id=amenazas>Amenazas</h1>
				</header>
<p>En sistemas de información se entiende por
<a target=_blank href=https://es.wikipedia.org/wiki/Seguridad_informática>amenaza</a>
la presencia de uno o
más factores de diversa índole (personas, máquinas o sucesos) que -de
tener la oportunidad- atacarían al sistema produciéndole daños
aprovechándose de su nivel de vulnerabilidad. Hay diferentes tipos de
amenazas de las que hay que proteger al sistema, desde las físicas como
cortes eléctricos, fallos del hardware o riesgos ambientales hasta los
errores intencionados o no de los usuarios, la entrada de software malicioso
(virus, troyanos, gusanos) o el robo, destrucción o modificación de la
información.
<p>En función del tipo de alteración, daño o intervención que podrían
producir sobre la información, las amenazas se clasifican en cuatro grupos:
<dl>
	<dt>De interrupción.<dt>
	<dd>El objetivo de la amenaza es deshabilitar el acceso a la
		información; por ejemplo, destruyendo componentes físicos
		como el disco duro, bloqueando el acceso a los datos, o
		cortando o saturando los canales de comunicación.</dd>
	<dt>De interceptación.</dt>
	<dd>Personas, programas o equipos no autorizados podrían acceder
		a un determinado recurso del sistema y captar información
		confidencial de la organización, como pueden ser datos,
		programas o identidad de personas.</dd>
	<dt>De modificación.</dt>
	<dd>Personas, programas o equipos no autorizados no solamente
		accederían a los programas y datos de un sistema de
		información sino que ade­más los modificarían. Por ejemplo,
		modificar la respuesta enviada a un usuario conectado o
		alterar el comportamiento de una aplicación instalada.</dd>
	<dt>De fabricación.</dt>
	<dd>Agregarían información falsa en el conjunto de información
		del sistema.</dd>
</dl>
<p>Según su origen las amenazas se clasifican en:
<dl>
	<dt>Accidentales.</dt>
	<dd>Accidentes meteorológicos, incendios, inundaciones, fallos en
	los equipos, en las redes, en los sistemas operativos o en el
	software, errores humanos.</dd>
	<dt>Intencionadas.</dt>
	<dd>Son debidas siempre a la acción humana, como la introducción de
	software malicioso - malware - (aunque este penetre en el sistema
	por algún procedimiento automático, su origen es siempre humano),
	intrusión informática (con frecuencia se produce previa la
	introducción de malware en los equipos), robos o hurtos. Las
	amenazas intencionadas pueden tener su origen en el exterior de la
	organización o incluso en el personal de la misma.</dd>
</dl>
			</section>
			<section id=Situacion>
				<header>
					<h1 id=situacion>Situación de error</h1>
				</header>
<p>Las situaciones de error se producen por diferentes causas, como una
<em>implementación incorrecta</em>, cuando el código no se ajusta a las
especificaciones, una <em>petición de objeto inapropiada</em>, como un
índice no válido (en un vector) o una referencia nula, o que el estado
de un objeto sea inapropiado o inexistente.
<p>Pero no siempre es devido a un error de programación. Pueden producirse
errores en el entorno, como la introduccion errónea de los datos o que se
produzca una interrupción en las comunicaciones; también, durante el
procesamiento de ficheros como que no exista el archiuvo al que desamos
acceder o que los permisos de acceso sean inadecuados.
<h2>Programción defensiva</h2>
Estos acontecimientos provocan que, para garantizar el correcto funcionamiento
de las aplicaciones, deba utilizarse la técnica de la
<a target=_blank href=https://es.wikipedia.org/wiki/Programaci%C3%B3n_defensiva>programación defensiva</a>,
que conlleva la incorporación de un gran número de comprobaciones, con la
consiguiente merma en rendimiento.
<p>Pero, ¿qué cosas deben ser comprobadas? ¿Debe tratarse el fallo en el 
punto en que se produce o se informa de los errores al código que invocó
a aquél en que se ha producido? ¿cómo debe tratarse el error? Si el error
no se trata, ¿cómo se informa del mismo? ¿Puede el código anticiparse al
fallo? Y si lo hace, ¿cuándo?
<p>Veamos un ejemplo sencillo. Supongamos que tenemos una agenda;
identificamos las entradas en la misma mediante algún tipo de clave que
podemos utilizar para localizarlas. Queremos borrar un registro: localizamos
el mismo a través de su clave y, a continuación, lo eliminamos:
<pre style=code>
	public void eliminar ( String clave ) {
		Contacto contacto = agenda.buscar(clave);
		agenda.borrar(contacto);
	}
</pre>
<p>Se produce un error: por ejemplo, que el registro no existe. ¿Quién tiene
la culpa? En general, es preferible anticiparse a quejarse.
<h3>Comprobación de clave</h3>
<p>Los argumentos son una vulnerabilidad:
<ul>
	<li>Inicializan el estado en un constructor
	<li>Contribuyen al comportamiento en un método
</ul>
<p>La comprobación de los argumentos es una medida defensiva:
<pre style=code>
	public void eliminar ( String clave ) {
		Contacto contacto;
		if ( agenda.existe(clave) ) {
			contacto = agenda.buscar(clave);
			agenda.borrar(contacto);
		}
	}
</pre>
<p>En este caso, comprobamos si existe el registro que deseamos eliminar
antes de proceder al borrado.
<h3>Información del error</h3>
<p>El modelo clásico para informar de que se ha producido un error es la
devolución de un diagnóstico. Por ejemplo, el método puede ser implementado
como una función booleana que devuelva verdadero solo si la operación se ha
realizado con éxito:
<pre style=code>
	public boolean eliminar ( String clave ) {
		Contacto contacto;
		if ( agenda.existe(clave) ) {
			contacto = agenda.buscar(clave);
			agenda.borrar(contacto);
			return true;
		} else
			return false;
	}
</pre>
<p>La salida de la función deberá ser comprobada por el método que la invocó:
<pre style=code>
	if ( ! objeto.metodo(parametros) ) {
		// tratar error
	} else {
		// código normal
	}
</pre>
<p>Este es un método sencillo pero que complica el código innecesariamente
debido a la anidación. Además, pueden producirse otros tipos de errores de
ejecución que no son capturables.
<p>Los lenguajes modernos, especialmente los que soportan la programación
orientada al objeto. incorporan un mecanismo de gestión del error a través
de las denominadas
<a target=_blank href=https://es.wikipedia.org/wiki/Manejo_de_excepciones>excepciones</a>.
<p>La estructura del código en este caso, como antes, tiene dos partes, la
del método invocado, en el que se produce el error, y el que invoca, en el
que el error puede ser tratado. En el primero, cuando se produce el error,
bien sea porque se incumple alguna condición o porque hay algún error en el
entorno, se indica la excepción y se finaliza la ejecución del método. En el
segundo, se codifican dos partes diferenciadas: la secuencia de ejecución
normal, por un lado, y el tratamiento del error, por el otro.
			</section>
			<section id=Excepciones>
				<header>
					<h1 id=excepciones>Excepciones en Java</h1>
				</header>
<p>El lenguaje de programación
<a target=_blank href= https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html>Java</a>
hace uso de las excepciones para indicar cuándo se ha producido un error.
Siguiendo la filosofía del lenguaje, una excepción es un objeto; el objeto
será una instancia de la clase
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Throwable.html>Throwable</a>
o de alguna de sus subclases, que transporta información desde el punto en
el que se ha producido el error. Como subclases podemos encontrar
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Error.html>Error</a> y
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Exception.html>Exception</a>. La primera es utilizada por la
propia máquina virtual de Java y hace referencia a errores irrecuperables
que no se tratan. La segunda hace referencia a errores que el programador
debería tratar.
<p>Así pues, nuestras
<a target=_blank href=https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html>excepciones</a>,
serán instancias de la clase <em>Exception</em>. Además, de éstas,
existen también dos tipos: las que no requieren comprobación y las que
deben comprobarse. Las primeras se corresponden con errores de ejecución
durante el funcionamiento normal de la JVM y se identifican con la superclase
<a target=_blank href=https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/RuntimeException.html>RuntimeException</a>. El resto son
conocidas como <em>checked exceptions</em>
			</section>
			<footer>
<nav class=pie>
        <a class=previo></a>
        <a class=inicio></a>
        <a class=siguiente></a>
</nav>
		<p>Programación de servicios y procesos</p>
			</footer>
		</article>
	</body>
</html>
